import: test_issue.yml.template

globals:
    score_array:
        path: matching_score_array.csv
        type: int

entities:
    person:
        fields:
            - x: {type: int, initialdata: True}
            - sex: {type: int, initialdata: True}

        processes:
            create():
                - new('person', number=1, id=0, x=0, sex=0)
                - new('person', number=1, id=1, x=1, sex=0)
                - new('person', number=1, id=2, x=2, sex=0)
                - new('person', number=1, id=3, x=0, sex=1)
                - new('person', number=1, id=4, x=1, sex=1)
                - new('person', number=1, id=5, x=2, sex=1)

            test_issue():
                # * "score=score_array[x, other.x]" does not work because axes labels are ambiguous

                # * "score=score_array[{'X1': x, 'X2': other.x}]" is annoying because it requires the whole expression
                #   to be quoted (with different quotes than the dict keys), otherwise it's not valid yaml.
                #   it also currently does not work because x and other.x are not considered to be used
                #   (but I think that part could be fixed)

                # * we could probably make "score=score_array[X1[x], X2[other.x]]" work but it would be annoying if axes
                #   have the same name as variables (which is very likely)
                - id_of_match: matching(set1filter=sex == 0,
                                        set2filter=sex == 1,
                                        orderby=-x,
                                        score=score_array[X.X1[x], X.X2[other.x]])

                # expected behavior :
                # 1) first id 0 is considered as it has the highest value of -x for set1 (sex == 0)
                #    it is matched with id 4 which has the highest score for id 0 (X1=0)
                # 2) then id 1 is considered
                #    it is matched with id 5 which has the highest score for id 1 (X1=1)
                # 3) then id 2 is considered
                #    it is matched with id 3 because it is the only remaining in set 2 (even though id 3 has not the
                #    highest score for id 2 *overall* but well in those remaining)
                - assertTrue((id_of_match == array([4, 5, 3, 2, 0, 1])).all())

                # same thing with algo=byvalue
                - id_of_match: matching(set1filter=sex == 0,
                                        set2filter=sex == 1,
                                        orderby=-x,
                                        score=score_array[X.X1[x], X.X2[other.x]],
                                        algo='byvalue')
                - assertTrue((id_of_match == array([4, 5, 3, 2, 0, 1])).all())
