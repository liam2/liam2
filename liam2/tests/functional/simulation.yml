import:
    - imported1.yml
    - imported2.yml

globals:
    periodic:
        path: param/globals.csv
        transposed: True
        fields:
            # PERIOD is implicit

            # WEMRA is defined in imported1.yml. It works even though no "path"
            # key is specified in imported1.yml (as if the periodic table was in
            # the H5 file) and even though it is specified using the "shortcut
            # syntax" for periodic globals because that syntax is expanded
            # before merging imported models, so it just do the right thing.

            - MINR: float
            - MIG_PERCENT: float

    ARRAY:
        type: float

    MIG:
        path: param/mig.csv
        type: float

    othertable:
        path: param/othertable.csv
        fields:
            - PERIOD: int
            - INTFIELD: int
            - FLOATFIELD: float

    othertable_noperiod:
        fields:
            - INTFIELD: int

entities:
#    test:
#        fields:
#            - test_field: int

    region:
        links:
            households: {type: one2many, target: household, field: region_id}

    household:
        fields:
            - num_persons:  {type: int, initialdata: False}
            - nch:          {type: int, initialdata: False}
            - start_period: {type: int, initialdata: False}
            - clone_id:     {type: int, initialdata: False}
            - weight:       {type: int, initialdata: False}
            - region_id:    {type: int, initialdata: False}

            # period and id are usually implicit, but we include them here
            # anyway for the sake of testing
            - period: int
            - id: int

        links:
            region: {type: many2one, target: region, field: region_id}
            persons: {type: one2many, target: person, field: hh_id}

        processes:
            init_region:
                - region_id: choice([0, 1, 2], [0.55, 0.35, 0.10])

            setweight:
                - weight: randint(2, 32)

            expand:
                - last_non_clone_id: max(id)
                - toclone: weight > 1
                - clone_id: clone(toclone)
                - is_clone: id > last_non_clone_id
                - weight: if(toclone,
                             trunc((weight + 1) / 2),
                             if(is_clone,
                                trunc(weight / 2),
                                1))

            check:
                - show('min/max weight:', min(weight), max(weight))
                - show('total population:', sum(persons.count()),
                       '/ expanded:', sum(weight * persons.count()))

            composition:
                - num_persons: persons.count()
                - nch: persons.count(age <= 18)

                # TODO: make this work
#                - nch_macro: persons.count(ISCHILD)

            dump_csv_h:
                - csv(dump())

            test_align_link:
                - num_persons: persons.count()
                # kill empty households
                - remove(num_persons == 0)

                - total_population: sum(num_persons)
                - show("total:", count(), "households /",
                                 total_population, "persons")

                # MIG_PERCENT is a simple float periodic global
                - num_migrants: total_population * MIG_PERCENT
                - qshow(num_migrants)

                # MIG is a 3d table but we want the 2d table for this period
                # currently, we need to manually compute the index
                - base_period: 2000
                - mig_period: MIG[:,:,period - base_period]

                # Distribute total desired migrants, by age and sex
                - need: num_migrants * mig_period

                # sanity check
                - assertTrue(abs(need.sum() - num_migrants) < 1e-4)

                # without filter
                - aligned_all: align_abs(persons.count(), need,
                                         link=persons, secondary_axis=gender)
                - qshow(count(aligned_all),
                        sum(num_persons, filter=aligned_all))

                # with a filter
                - is_candidate: uniform() < 0.5
                - qshow(count(is_candidate),
                        sum(num_persons, filter=is_candidate))

                - aligned: align_abs(persons.count(), need,
                                     link=persons, secondary_axis=gender,
                                     errors='carry',
                                     filter=is_candidate)
                - qshow(count(aligned),
                        sum(num_persons, filter=aligned))

#                - clone_id: clone(aligned)

                # with pvalues != range(0, X)
                - bchoice: choice([False, True])
                - weird_num: choice([5, 25, 45, 65, 85, 105])
                - weird_need: groupby(bchoice, weird_num, expr=10)
                - show(weird_need)
                - show('by sex', weird_need.sum(axis=1))
                - aligned: align_abs(persons.count(), weird_need,
                                     link=persons, secondary_axis=0,
                                     filter=is_candidate,
                                     expressions=[gender, 5 + trunc(age / 20) * 20])
                - qshow(count(aligned),
                        sum(num_persons, filter=aligned))


    person:
        fields:
            # period and id are implicit
            - age:          int
            # we only use the dead field to remove dead persons in init
            - dead:         bool
            - gender:       bool
            - work:         bool

            - partner_id:   int
            - hh_id:        int
            - f_id:         int
            - m_id:         int

            - weight:       {type: int, initialdata: False}
            - eduach:       {type: int, initialdata: False}
            - agegroup:     {type: int, initialdata: False}
            - float_field1: {type: float, initialdata: False}
            - int_field1:   {type: int, initialdata: False}
            - hybrid_test:  {type: int, initialdata: False}
            - temp_global:  {type: int, initialdata: False, output: False}

        links:
            partner: {type: many2one, target: person, field: partner_id}
            household: {type: many2one, target: household, field: hh_id}
            household_bis: {type: many2one, target: household, field: hh_id}
            father: {type: many2one, target: person, field: f_id}
            mother: {type: many2one, target: person, field: m_id}
            children: {type: one2many, target: person, field: m_id}

        macros:
            ISCHILD: age < 18

#            BOY: ISCHILD and MALE
#            GIRL: ISCHILD and FEMALE

            MALE: gender
            FEMALE: not gender

            CONSTANT_MACRO: 3

            LOWER_SECONDARY_EDU: eduach == 2
            UPPER_SECONDARY_EDU: eduach == 3
            TERTIARY_EDU: eduach == 4

        # possible transitions & regressions. The actual list used in the
        # simulation must be defined below
        processes:
            bp:
                - breakpoint(2002)

            expand:
                - last_non_clone_id: max(id)
                - toclone: household.clone_id != -1
                - clone_id: clone(toclone)

                - is_clone: id > last_non_clone_id

                - hh_id: if(is_clone, household.clone_id, hh_id)
                - m_id: if(is_clone, mother.clone_id, m_id)
                - f_id: if(is_clone, father.clone_id, f_id)
                - partner_id: if(is_clone, partner.clone_id, partner_id)

            test_proc:
                # same name than in the caller function, but should be local
                - temp_var: age * 1
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

            # should raise a warning because it does not make sense (but it
            # is not supported by new syntax)
#            func_only_args_oldsyntax:
#                args: a, b

#            func_only_code_oldsyntax:
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age
#                    - local_var: temp_var * 2
#                    - assertEqual(local_var, age * 2)
#                    # update global variable
#                    - int_field1: age + 1

            func_only_code():
                # same name than in the caller function, but should be local
                - temp_var: age
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

#            func_only_return_oldsyntax:
#                return: age + 1

            func_only_return():
                - return age + 1

#            func_no_args_oldsyntax:
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age
#                    - local_var: temp_var * 2
#                return: local_var * 2

            func_no_args():
                # same name than in the caller function, but should be local
                - temp_var: age
                - local_var: temp_var * 2
                - return local_var * 2

#            func_no_code_oldsyntax:
#                args: a, b
#                return: a + b

            func_no_code(a, b):
                - return a + b

#            func_no_return_oldsyntax:
#                args: a, b
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age * 1
#                    - local_var: temp_var * 2
#                    - assertEqual(local_var, age * 2)
#                    # update global variable
#                    - int_field1: age + 1

            func_no_return(a, b):
                # same name than in the caller function, but should be local
                - temp_var: age * 1
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

#            func_args_code_result_oldsyntax:
#                args: a, b
#                code:
#                    - result: a + b
#                    - result: result * 2
#                return: result * 2

            func_args_code_result(a, b):
                - result: a + b
                - result: result * 2
                - return result * 2

            func_args_conflict_fields(age):
                - qshow(age)

            # issue 119: function arguments not available in interactive console
            issue119callee(arg):
                - localarg: arg
                # function arguments are not available in the interactive
                # console, but local variables work fine:
                # >>> arg
                # name 'arg' is not defined
                # >>> localarg
                # 1.0
                - show("type 'arg' and see if it is defined")
                - breakpoint()

            # this is an awful hack since we do not have an if control flow
            # keyword yet
            factorial(n):
                - r: 0
                - while n > 1:
                    - r: n * factorial(n - 1)
                    - n: 0
                - while n == 1:
                    - r: 1
                    - n: 0
                - return r

            factorial2(n):
                - while n > 1:
                    - return n * factorial2(n - 1)
                - return n

            factorial3(n):
                - while n <= 1:
                    - return n
                - r: 1
                - while n > 1:
                    - r: r * n
                    - n: n - 1
                - return r

            test_call:
                # 1) no args and no result (concise/old style)
                - temp_var: age * 42
                - int_field1: age + 42
                - assertEqual(int_field1, age + 42)
                - test_proc()
                - assertEqual(int_field1, age + 1)
                # make sure the local variable did not change
                - assertEqual(temp_var, age * 42)

                # 2) no args and no result (verbose/new style)
                - int_field1: age + 42
                - assertEqual(int_field1, age + 42)
                - func_only_code()
                - assertEqual(int_field1, age + 1)
                # make sure the local variable did not change
                - assertEqual(temp_var, age * 42)

#            func_only_args(a, b)
#            func_only_return() # -> age + 1
#            func_no_args() # -> age * 4
#            func_no_code(a, b) # -> a + b
#            func_no_return(a, b) # no return but int_field1: age + 1
#            func_args_code_result:

                - assertEqual(factorial(0), 0)
                - assertEqual(factorial(1), 1)
                - assertEqual(factorial(2), 2)
                - assertEqual(factorial(3), 6)
                - assertEqual(factorial(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial(12), 479001600)

                - assertEqual(factorial2(0), 0)
                - assertEqual(factorial2(1), 1)
                - assertEqual(factorial2(2), 2)
                - assertEqual(factorial2(3), 6)
                - assertEqual(factorial2(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial2(12), 479001600)

                - assertEqual(factorial3(0), 0)
                - assertEqual(factorial3(1), 1)
                - assertEqual(factorial3(2), 2)
                - assertEqual(factorial3(3), 6)
                - assertEqual(factorial3(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial3(12), 479001600)

                # generic call (ndarray methods)
                # without argument
                - assertEqual(age.sum(), sum(age))
                - assertEqual(age.std(), std(age))
                - assertEqual(age.max(), max(age))
                - assertEqual(age.min(), min(age))

                # with constant argument
                - assertEqual(age.min(axis=-1), min(age))

                # with expr argument
                - axis: 0
                - assertEqual(age.min(axis=axis), min(age))

            test_issue119:
                - issue119callee(1.0)

            test_issue120:
                # breakpoint to test issue 120: global temp produces
                # warning in the interactive console. It needs to be
                # called *after* the "temp_global" process !
                - show("type 'age' and see if produces a warning")
                - breakpoint()

            # issue126: prevent function arguments named like fields
            test_issue126:
                - age_backup: age
                - func_args_conflict_fields(age + 10)
                - assertEqual(age, age_backup)

            hybrid_test:
                - hybrid_test: age + 1
                - assertEqual(hybrid_test, age + 1)

            test_hybrids:
                # hybrid = both a variable and a method
                # stored = in fields

                # temporary global (single-expr process) => hybrid
                # * manual call
                - hybrid_temp_global()
                # * in agespine (tested before)
                # * used in expr
                - assertEqual(hybrid_temp_global, age + 10)

                # stored + single-expr process => hybrid
                # * manual call
                - compute_agegroup()
                # * in agespine (tested before)
                # * used in expr (tested in many tests but lets do it here too)
                - local: agegroup * 10
                - assertEqual(local, agegroup * 10)

                # stored + function => hybrid (+ warn?)
                # * manual call
                - hybrid_test()
                # * in agespine (tested before)
                # * used in expr
                - assertEqual(hybrid_test - 1, age)

            # should raise an informative error message in 0.10 at least
#            test_while_oldsyntax:
#                - values: age
#                - while:
#                    cond: min(values) < 5
#                    code:
#                        - values: values + 1


            test_while:
                - values: age
                - while min(values) < 5:
                    - values: values + 1

                - i: 5
                - assertEqual(i, 5)
                - while i:
                    - i: i - 1
                - assertEqual(i, 0)

            # pi using the Nilakantha series
            # pi = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) + ...
            test_pi_nilakantha:
                - numiter: 10
                - pi: 3
                - n: 4
                - d: 2
                - i: 0
                - while i < numiter:
                    - pi: pi + n / (d * (d + 1) * (d + 2))
                    - n: -n
                    - d: d + 2
                    - i: i + 1
                - show("pi approximation after", numiter, "iterations:", pi)

#            test_for:
#                - n: 42
#                # => for is a reserved keyword and can't be used as a
#                #    variable name
#                - for:
#                    variables: i
#                    in: [0, 1, 2, 3]
#                    code:
#                        - show("i:", i, "/ n + i:", n + i)
#                        - show("age:", age)

                 # two variables
#                - for:
#                    variables: index, letter
#                    in: zip([0, 1, 2], ["a", "b", "c"])
#                    code:
#                        - show("index", index, "letter", letter)

             # this will need to be represented by special objects anyway,
             # so let us first do the ugly but easier (to implement) syntax
#            embedded_python:
#                done = False
#                while not done:
#                    age += 1
#                    done = min(age) >= 10

            test_charts:
# commented so that the tests can run without interaction
#                - plot(groupby(age))
                - plot(groupby(age), suffix='test')

                - boxplot(age[gender], age[not gender],
                          fname='bplot1.png&pdf')
                - boxplot((age[gender], age[not gender]),
                          fname='bplot1bis.png')
                - boxplot(groupby(eduach, expr=age, filter=eduach != -1),
                          fname='bplot2.png&pdf')
                - boxplot(groupby(eduach, expr=age, filter=eduach != -1),
                          notch=True, fname='bplot3.png')

                - plot(age, fname='plot01_{entity}_{period}.png')
                - plot(age, 'o', fname='plot02.png')
                - plot(groupby(age), fname='plot03.png&pdf')
                - plot(groupby(age),
                       groupby(age, expr=count(not gender)),
                       groupby(age, expr=count(gender)),
                       fname='plot04.png&pdf')
                - plot((lag(avg(work), 5), lag(avg(work), 4),
                        lag(avg(work), 3), lag(avg(work), 2),
                        lag(avg(work)), avg(work)), fname='plot05.png')
                - plot(groupby(age, gender), fname='plot06.png&pdf')
                - plot(groupby(age, gender), colors=('g', 'b'),
                       fname='plot07.png')
                - plot(groupby(agegroup, gender), styles=['--', '-'],
                       fname='plot08.png')
                - plot(groupby(agegroup, gender),
                       grid=False, linestyle='dashed', marker='o', linewidth=5,
                       fname='plot09.png&pdf')
                - plot(groupby(eduach), 's--', fname='plot10.png')
                - plot(groupby(eduach), 's--', color='g',
                       fname='plot11.png')
                - plot(groupby(agegroup, expr=count(not gender)), 'o--',
                       groupby(agegroup, expr=count(gender)), 's-.',
                       groupby(agegroup), '*-', colors=['r', 'g', 'b'],
                       fname='plot12.png&pdf')

                - stackplot(groupby(eduach), fname='stackplot1.png')
                - stackplot(groupby(age, eduach), fname='stackplot2.png&pdf')
                - stackplot(groupby(eduach, gender),
                            colors=['g', 'b'], baseline='sym',
                            fname='stackplot3.png')
                - stackplot(groupby(age, expr=count(not gender)),
                            groupby(age, expr=count(gender)),
                            fname='stackplot4.png')

                - byage: groupby(age, percent=True)
                - bar(byage, fname='bar1.png')
                - bar(groupby(agegroup), fname='bar2.png&pdf')
                - bar(groupby(agegroup + 1), fname='bar3.png')
                - bar(groupby(agegroup, gender), fname='bar4.png')
                - bar(groupby(agegroup, filter=not gender),
                      groupby(agegroup, filter=gender),
                      fname='bar5.png&pdf')
                - bar(groupby(agegroup, eduach), fname='bar6.png&pdf')
                - bar(groupby(agegroup, eduach), width=0.8, fname='bar7.png')
                # mig_period_women
                - bar(MIG[0,:,period - 2001], fname='bar8.png')

                # axes are currently messed up
                # - barh(groupby(agegroup, eduach))
                # - barh(groupby(agegroup, eduach), height=0.7)

                - pie(groupby(eduach), fname='pie1.png&pdf')
                - pie(groupby(eduach),
                      explode=[0.1, 0, 0],
                      labels=['Lower secondary', 'Upper secondary', 'Tertiary'],
                      fname='pie2.png&pdf')

                # limit number of individuals to get smaller .pdf files
                - num: 200
                - salary: 10000 + uniform(size=num) * 50000
                - area: 3.1415 * (4 + 1.5 * children.count()[:200]) ** 2
                - scatter(age[:num], salary, c=eduach[:num], s=area, grid=True,
                          fname='scatter1.png&pdf')
                # r=expr is equivalent to s=pi * expr ** 2
                - scatter(normal(size=num), normal(size=num), c=age[:num],
                          r=2 ** eduach[:num], alpha=0.8,
                          fname='scatter2.png&pdf')

            test_init:
                - eduach: choice([2, 3, 4], [0.40, 0.35, 0.25])
                - weight: randint(1, 11)
#                - new('person', number=10000000,
#                      age=randint(102),
#                      gender=choice([True, False], [0.5, 0.5]),
#                      work=choice([True, False], [0.5, 0.5]),
#                      partner_id=1)
                # fix incoherent partners
                - bad_partner: partner_id != -1 and partner.partner.id != id
                - partner_id: if(bad_partner, -1, partner_id)
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            test_remove_init:
                # dead True only comes from the input
                - numdead: count(dead)
                - total: count()
                - partner_id: if(partner.dead, -1, partner_id)
                - f_id: if(father.dead, -1, f_id)
                - m_id: if(mother.dead, -1, m_id)
                - remove(dead)
                - assertEqual(count(), total - numdead)
                - assertTrue(all(not dead))
                - assertTrue(all(age >= 0))
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            hybrid_temp_global: age + 10

            set_hybrid_temp_global:
                - hybrid_temp_global: hybrid_temp_global * 2
            check_hybrid_temp_global:
                - assertEqual(hybrid_temp_global, (age + 10) * 2)

            set_temp_global:
                - temp_global: age + 10
            check_temp_global:
                - assertEqual(temp_global, age + 10)

            test_expr:
                - show("count:", count())
                - show("age:", age)
                - show("age + 1:", age + 1)
                - show("age / 10:", age / 10)
                - show("100 / age:", 100 / age)
                - show("age * (1 / 2):", age * (1 / 2))
                - show("clip(age, 10, 50)", clip(age, 10, 50))

                # test we are not having aliases problems
                - backup: age
                # modify it. This occurs in place, because the field is stored
                # in the main array.
                - age: age + 1
                - assertEqual(age, backup + 1)
                - age: backup

            test_trunc:
                - assertTrue(all(age >= 0))
                - diff: (age / 5) - trunc(age / 5)
                - assertTrue(all(0.0 <= diff and diff < 1.0))
                - assertTrue(any(diff > 0.0) and any(diff == 0.0))

# TODO: move these tests somewhere more appropriate
                # this tests the argument-checking code for "_compute"-based
                # functions.
#                - trunc()
#                - trunc(1, 2, 3)

                # this tests the argument-checking code for
                # "NumpyFunction"-based functions
#                - clip(age, 5)
#                - clip(age, 5, 10, 15, 20)

            test_seed:
                - seed(0)
                - value1: uniform()
                - seed(0)
                - value2: uniform()
                - assertEqual(value1, value2)

            test_logit:
                - float_field: age / 120.0
                - assertNanEqual(logit(float_field),
                                 log(float_field / (1.0 - float_field)))

            test_logistic:
                - assertEqual(logistic(age), 1.0 / (1.0 + exp(-age)))
                - float_field: age * 1.0
                - assertEqual(logistic(float_field),
                              1.0 / (1.0 + exp(-float_field)))

            test_attr:
                - assertEqual(age.ndim, 1)

            test_subscript:
                # with constant argument
                # take advantage of the fact that data is ordered by id
                - assertEqual(id[0], min(id))

                # with expr argument
                - newborn: age[age == 0]
                - assertEqual(newborn[0], 0)

                # with slice
                - assertEqual(age[0:1], [age[0]])

                # with expr slice
                - index: trunc(count() / 2)
                - ages: age[index:index+10:2]
                - assertEqual(ages.__len__(), 5)
                - assertEqual(ages[0], age[index])

            test_periodic_globals:
                # implicit global namespace
                # -------------------------
                - fake_wemra: if(period <= 1996, 60,
                              if(period <= 1999, 61,
                              if(period <= 2002, 62,
                              if(period <= 2005, 63,
                              if(period <= 2008, 64, 65)))))
                - fake_wemra_pm1: if(period <= 1997, 60,
                                  if(period <= 2000, 61,
                                  if(period <= 2003, 62,
                                  if(period <= 2006, 63,
                                  if(period <= 2009, 64, 65)))))
                # no index
                - assertEqual(WEMRA, fake_wemra)
                # const_index
                - assertEqual(MINR[2005], 13620.2)
                # (scalar) expr index
                - assertEqual(WEMRA[period - 1], fake_wemra_pm1)

                # Test that the generated variable name is the same for the
                # same global when it is used multiple time (if the period
                # is the same).
                # This is an indirect test because I cannot test this directly
                # yet (this should be a unit test instead).
                # We know numexpr will explode with a ValueError("too many
                # inputs") when there are more than 31 different variables,
                # so if this test passes it means it worked.
                - assertEqual(WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA,
                              WEMRA * 36)

                - globals_in_expr: 1.0 + MINR
                - idx_globals_in_expr: 1.0 + MINR[2002]
                - expr_idx_globals_in_expr: 1.0 + MINR[period - 1]

                # index by a vector
                - yearofbirth: period - age
                - yearofpension: yearofbirth + 65
                - result: MINR[yearofpension]
                - assertEqual(result[0], MINR[yearofpension[0]])

                # test for issue 121 (ie GLOBAL[large_negative] was very slow)
                # In the initial report, it was created with trunc(nan)
                # (= -2147483648).
                - bad_index: if(id >= 0, -2147483648, -1)
                # This takes ~1 minute wh/out the fix and < 1 ms with it.
                - MINR[bad_index]

                # test slices

                # a) slices of constant lengths
                #    (ie. all(stop - start == stop[0] - start[0]))
                #    result is a 2D array: num_individuals x slice_length

                #    1) scalar bounds
                - scalar_bounds: MINR[period:period + 2].sum()
                - assertEqual(scalar_bounds, MINR[period] + MINR[period + 1])

                #    2) scalar start, vector stop
                - scalar_start: MINR[period:age - age + period + 10]
                - assertNanEqual(scalar_start[0][0], MINR[period])
                - assertNanEqual(scalar_start[0][9], MINR[period + 9])

                #    3) vector start, scalar stop
                - scalar_stop: MINR[age - age + period:period + 10]
                - assertNanEqual(scalar_stop[0][0], MINR[period])
                - assertNanEqual(scalar_stop[0][9], MINR[period + 9])

                #    4) vector start, vector stop
                - vector_bounds: MINR[yearofbirth:yearofpension]
                - assertNanEqual(vector_bounds[0],
                                 MINR[yearofbirth[0]:yearofpension[0]])

                # b) slices of varying length
                #    (ie. any(stop - start != stop[0] - start[0]))
                #    result is an IrregularNDArray:
                #    num_individuals x slice lengths
                - yearofpension: yearofbirth + if(gender, 65, WEMRA)

                #    1) scalar start, vector stop
                - scalar_start: MINR[period:yearofpension]
                - assertNanEqual(scalar_start[0], MINR[period:yearofpension[0]])

                #    2) vector start, scalar stop
                # + 1 to not get all nan the first period
                - scalar_stop: MINR[yearofbirth:period + 1]
                - assertNanEqual(scalar_stop[0],
                                 MINR[yearofbirth[0]:period + 1])

                #    3) vector start, vector stop
                - vector_bounds: MINR[yearofbirth:yearofpension]
                - assertNanEqual(vector_bounds[0],
                                 MINR[yearofbirth[0]:yearofpension[0]])

                # test IrregularNDArray methods
                - assertEqual(vector_bounds.prod(axis=1).__len__(), count())
                - assertEqual(vector_bounds.sum(axis=1).__len__(), count())

                # explicit "periodic" namespace
                # -----------------------------
                # no index
                - assertEqual(periodic.WEMRA, fake_wemra)
                # const_index
                - assertEqual(periodic.MINR[2005], 13620.2)
                # expr_index
                - assertEqual(periodic.WEMRA[period - 1], fake_wemra_pm1)
                - vector_idx: periodic.MINR[yearofbirth + 65]

            test_other_globals:
                # with a PERIOD column
                - fake_intfield: if(period <= 1979, -1,
                                 if(period <= 1996, 60,
                                 if(period <= 1999, 61,
                                 if(period <= 2002, 62,
                                 if(period <= 2005, 63,
                                 if(period <= 2008, 64,
                                 if(period <= 2010, 65, -1)))))))
                - assertEqual(othertable.INTFIELD, fake_intfield)
                # expr_index
                - assertEqual(othertable.INTFIELD[period], fake_intfield)

                - baseperiod: 1980
                - assertEqual(othertable_noperiod.INTFIELD[0], 60)
                # expr_index
                - assertEqual(othertable_noperiod.INTFIELD[period - baseperiod],
                              fake_intfield)
                # this is equivalent to INTFIELD[2002], so it is (way) out of
                # bounds but it does not fail, it simply returns "missing"
                # FIXME: it should not be allowed (ie not all global variable
                # should have this "current period if not indexed" behavior.
                - assertEqual(othertable_noperiod.INTFIELD, -1)

            test_globals_nd:
                # MIG is a 3d array: gender-age-period

                # test that MIG was loaded correctly
                - assertEqual(MIG.ndim, 3)
                - assertEqual(MIG.shape, (2, 121, 61))
                - assertEqual(MIG.dim_names, ['gender', 'age', 'period'])

                # need should have the same characteristics
                - need: MIG * 2.5
                - assertEqual(need.ndim, 3)
                - assertEqual(need.shape, (2, 121, 61))
                - assertEqual(need.dim_names, ['gender','age', 'period'])

                # nd_plus_nd should have the same characteristics too
                - nd_plus_nd: need + MIG
                - assertEqual(nd_plus_nd.ndim, 3)
                - assertEqual(nd_plus_nd.shape, (2, 121, 61))
                - assertEqual(nd_plus_nd.dim_names, ['gender','age', 'period'])
                - assertIsClose(nd_plus_nd, 3.5 * MIG)

                # let us take the 2d table for this period
                # currently, we need to compute the index manually
                - base_period: 2000
                - mig_period: MIG[:,:,period - base_period]
                - assertEqual(mig_period.ndim, 2)
                - assertEqual(mig_period.shape, (2, 121))
                - assertEqual(mig_period.dim_names, ['gender', 'age'])
                - assertEqual(mig_period.pvalues.__len__(), 2)

                # test that expressions with more than one dimension (2 in
                # this case) work when the axes from both sides are not the
                # same objects (this is the case in the need and nd_plus_nd
                # tests above)
                - mig_period_bis: MIG[:,:,period - base_period]
                - mig_period_x2: mig_period + mig_period_bis
                - assertEqual(mig_period_x2, mig_period * 2)

                # should be a 2d table: gender-period
                - need_by_sex_period: need.sum(axis=1)
                - assertEqual(need_by_sex_period.ndim, 2)
                - assertEqual(need_by_sex_period.shape, (2, 61))
                # LabeledArray does not support reduction functions for now,
                # so need_by_sex_period is not a LabeledArray
                #- assertEqual(need_by_sex_period.dim_names, None)

                # should be a 1d table: gender
                - total_need_by_sex: need_by_sex_period.sum(axis=1)
                - assertEqual(total_need_by_sex.ndim, 1)
                - assertEqual(total_need_by_sex.shape, (2,))
                - assertIsClose(total_need_by_sex,
                                [77.6138352312, 74.8861646933])

                # for current period, a 1d table: gender
                # currently, we need to manually compute the index
                - need_by_sex: need_by_sex_period[:,period - base_period]
                - assertEqual(need_by_sex.ndim, 1)
                - assertEqual(need_by_sex.shape, (2,))

                - total_need: need_by_sex.sum()
                - assertEqual(total_need.ndim, 0)
                - qshow(total_need)

                # vector indexes (should produce a non labeled vector)
                # ----------------------------------------------------

                # first, produce a 1 dim LabeledArray to test with
                - need_by_sex20: MIG[:, 20, period - base_period]
                - assertEqual(need_by_sex20.ndim, 1)
                - assertEqual(need_by_sex20.shape, (2,))
                - assertEqual(need_by_sex20.dim_names, ['gender'])

                # 1d array[int[:]]
                # gender can't be used directly as indices (we need integers)
                - need_per_person: need_by_sex20[gender * 1]
                - assertEqual(need_per_person.ndim, 1)
                - assertEqual(need_per_person.shape, (count(),))
                - assertEqual(need_per_person.dim_names, None)
                - assertEqual(need_per_person.pvalues, None)

                # 3d array[int[:], int[:], int]
                - base_period: 2000
                - percent_per_person: MIG[gender * 1, age, period - base_period]
                - assertEqual(percent_per_person.ndim, 1)
                - assertEqual(percent_per_person.shape, (count(),))
                - assertEqual(percent_per_person.dim_names, None)
                - assertEqual(percent_per_person.pvalues, None)
                - assertEqual(percent_per_person[0],
                              MIG[gender[0] * 1, age[0], period - base_period])

                # use the resulting vector in an expression

                # using a temporary variable
                - remainder_per_person: 1 - percent_per_person
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # via a field: this forces a conversion to a normal
                # (non-labeled) array
                - float_field1: percent_per_person
                - remainder_per_person: 1 - float_field1
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # direct use
                - remainder_per_person: 1 - MIG[gender * 1, age,
                                                period - base_period]
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # test an expr with two 3d array
                - strange: MIG[gender * 1, 0, 0] - MIG[gender * 1, 1, 0]
                - control1: MIG[:,0,:] - MIG[:,1,:]
                - control2: control1[gender * 1, 0]
                - assertIsClose(sum(strange), sum(control2))

                # test combination with if() filter, to test whether the
                # contextual filter works properly, especially with bad indices
                - true_: True
                - false_: False

                # scalar key
                # ----------
                - alltrue: age < 1000
                - allfalse: age > 1000

                # array filter
                - test1: if(alltrue, need_by_sex20[0], -1)
                - assertEquiv(test1, need_by_sex20[0])
                - test2: if(allfalse, need_by_sex20[0], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(allfalse, need_by_sex20[2], -1)
                - assertEquiv(test3, -1)

                # scalar filter
                - test1: if(true_, need_by_sex20[0], -1)
                - assertEqual(test1, need_by_sex20[0])
                - test2: if(false_, need_by_sex20[0], -1)
                - assertEqual(test2, -1)
                # bad index
                - test3: if(false_, need_by_sex20[2], -1)
                - assertEqual(test3, -1)

                # array key
                # ---------
                # 0 and 1 are the only valid indices for need_by_sex20
                - good_idx: if(age < 2, age, 0)
                - bad_idx: age
                - good_res: need_by_sex20[good_idx]
                - target: if(age < 2, good_res, 0)

                # array filter
                - test1: if(age < 2, need_by_sex20[good_idx], 0)
                - assertEqual(test1, target)
                - test2: if(age >= 2, 0, need_by_sex20[good_idx])
                - assertEqual(test2, target)
                # bad index
                - test3: if(age < 2, need_by_sex20[bad_idx], 0)
                - assertEqual(test3, target)
                - test4: if(age >= 2, 0, need_by_sex20[bad_idx])
                - assertEqual(test4, target)

                # scalar filter
                - test1: if(true_, need_by_sex20[good_idx], -1)
                - assertEqual(test1, good_res)
                - test2: if(false_, need_by_sex20[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(false_, need_by_sex20[bad_idx], -1)
                - assertEquiv(test3, -1)

                # tuple key
                # ---------
                - gender_idx: gender * 1
                - period_idx: period - base_period
                - good_idx: gender_idx, if(age < 70, age + 20, -1), period_idx
                - bad_idx1: gender_idx, age + 20, period_idx
                - bad_idx2: gender_idx, age, period_idx + 100
                - good_res: MIG[good_idx]
                - target: if(age < 70, good_res, -1)

                # array filter
                - test1: if(age < 70, MIG[good_idx], -1)
                - assertEqual(test1, target)
                - test2: if(allfalse, MIG[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(allfalse, MIG[bad_idx1], -1)
                - assertEquiv(test3, -1)
                - test4: if(allfalse, MIG[bad_idx2], -1)
                - assertEquiv(test4, -1)

                # scalar filter
                - test1: if(true_, MIG[good_idx], -1)
                - assertEqual(test1, good_res)
                - test2: if(false_, MIG[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(false_, MIG[bad_idx1], -1)
                - assertEquiv(test3, -1)
                - test4: if(false_, MIG[bad_idx2], -1)
                - assertEquiv(test4, -1)

            test_macro:
                - ischild: age < 18
                - test_nonmacro1: show(sum(ischild))
                - test_macro1: show(sum(ISCHILD))
#                - breakpoint(2002)

                - age: age + 1

                - test_nonmacro2: show(sum(ischild))
                - show("test sum:", sum(ischild))
                - test_macro2: show(sum(ISCHILD))

                - show('male students', count(MALE and LOWER_SECONDARY_EDU))

#                - show('expr wh missing parenthesis', count(age < 15 & eduach == 2))
                # equivalent to count(age < (15 & eduach) == 2)
                # equivalent to count((age < (15 & eduach)) *and* ((15 & eduach) == 2))
                # calls __nonzero__ on the first part (age < (15 & eduach))
                - show(groupby(eduach, gender))

            compute_agegroup:
                - agegroup: if(age < 50, 5 * trunc(age / 5), 10 * trunc(age / 10))

            test_align:
                - num_all: count()
                - num_women: count(not gender)
                - num_men: count(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align(age,
                                     expressions=[gender],
                                     possible_values=[[False, True]],
                                     proportions=[0.1, 0.2])
                - num_aligned: count(int_aligned)
                - num_aligned_women: count(int_aligned and not gender)
                - num_aligned_men: count(int_aligned and gender)
                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that older individuals are taken first
                - assertTrue(max(age, filter=gender and not int_aligned)
                             <=
                             min(age, filter=gender and int_aligned))
                - assertTrue(max(age, filter=not gender and not int_aligned)
                             <=
                             min(age, filter=not gender and int_aligned))

                # manual alignment on a float column (with nan)
                # ---------------------------------------------
                - nan_age: if(age < 10, nan, age * 1.0)
                - assertEqual(count(nan_age != nan_age), count(age < 10))
                - float_aligned: align(nan_age,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: count(float_aligned)
                - num_aligned_women: count(float_aligned and not gender)
                - num_aligned_men: count(float_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that nan are chosen first
                # we have two different scenarii:
                # 1) we have more "nan" than we need
                #    => we check that all taken are "nan"
                # 2) or we have less "nan" than we need
                #    => we check that all "nan" are taken / aligned
                # and we have to check separately for men and women

                - isnan: nan_age != nan_age

                # women

                # more than 10% women are "nan"
                - morenan: count(not gender and isnan) > num_women * 0.1
                # we use min as a lesser all()
                - all_taken_nan: min(isnan, filter=not gender and float_aligned)
                - all_nan_taken: min(float_aligned,
                                     filter=not gender and isnan)
                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # men

                # more than 20% men are "nan"
                - morenan: count(gender and isnan) > num_men * 0.2
                - all_taken_nan: min(isnan, filter=gender and float_aligned)
                - all_nan_taken: min(float_aligned, filter=gender and isnan)

                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # manual alignment with a constant
                # --------------------------------
                - const_aligned: align(False, filter=age < 10,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: count(const_aligned)
                - num_aligned_women: count(const_aligned and not gender)
                - num_aligned_men: count(const_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(max(id, filter=gender and (age < 10) and
                                               not const_aligned)
                             <=
                             min(id, filter=gender and const_aligned))
                - assertTrue(max(id, filter=not gender and (age < 10) and
                                               not const_aligned)
                             <=
                             min(id, filter=not gender and const_aligned))

                # manual alignment with no score
                # ------------------------------
                - none_aligned: align(filter=age < 10,
                                      expressions=[gender],
                                      possible_values=[[False, True]],
                                      proportions=[0.1, 0.2])
                - num_aligned: count(none_aligned)
                - num_aligned_women: count(none_aligned and not gender)
                - num_aligned_men: count(none_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(max(id, filter=gender and (age < 10) and
                                               not none_aligned)
                             <=
                             min(id, filter=gender and none_aligned))
                - assertTrue(max(id, filter=not gender and (age < 10) and
                                               not none_aligned)
                             <=
                             min(id, filter=not gender and none_aligned))

                # manual alignment with individuals in missing categories
                # -------------------------------------------------------

                - miss_aligned: align(filter=id < 100,
                                      expressions=[20 * trunc(age / 20)],
                                      possible_values=[[0, 20, 60, 80, 100]],
                                      proportions=[0.1, 0.1, 0.1, 0.1, 0.1])
                - num_aligned: count(miss_aligned)
                - assertTrue(num_aligned - 0.1 * num_all < 1.0)

                # alignment with an implicit filter
                # ---------------------------------

                - dead1: if(gender,
                            align(take=age > 95, leave=ISCHILD,
                                  fname='al_p_dead_m.csv'),
                            align(take=age > 95, leave=ISCHILD,
                                  fname='al_p_dead_f.csv'))

                - assertEqual(count(not dead1 and (age > 95)), 0)
                - assertEqual(count(dead1 and ISCHILD), 0)

                # 3d alignment (gender, age, period)
                # ----------------------------------
                - dead2: align(take=age > 95, leave=ISCHILD,
                               fname='al_p_dead.csv')

                - assertTrue(count(dead1 != dead2) <= 105)

                # 2d alignment with period not last
                # ---------------------------------
                - percent_f: if(period <= 2002, 0.2,
                             if(period <= 2003, 0.3, 0.4))
                - percent_m: percent_f + 0.1
                - aligned: align(fname='al_p_period_notlast.csv')

                - theoric_aligned_f: trunc(count(not gender) * percent_f)
                - theoric_aligned_m: trunc(count(gender) * percent_m)
                - diff_f: count(aligned and not gender) - theoric_aligned_f
                - diff_m: count(aligned and gender) - theoric_aligned_m
                - assertTrue((0 <= diff_f) and (diff_f <= 1))
                - assertTrue((0 <= diff_m) and (diff_m <= 1))
                - show('diff_f', diff_f, 'diff_m', diff_m)

                # 1d alignment (period)
                # ---------------------
                - period_only: align(fname='al_p_period_only.csv')
                - num_aligned: count(period_only)
                - target_percent: if(period == 2002, 0.2,
                                  if(period == 2003, 0.3,
                                  0.4))
                - assertTrue(num_aligned - target_percent * num_all < 1.0)

                # 1d alignment (other than period)
                # --------------------------------
                - by_gender: align(fname='al_p_one_dim.csv')

                - num_aligned: count(by_gender)
                - num_aligned_women: count(by_gender and not gender)
                - num_aligned_men: count(by_gender and gender)

                - assertTrue(num_aligned_women - 0.2 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.3 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # align using a temporary variable
                - temp: age + 1

                # these do not produce exactly the same values because of the
                # way we correct for "fractional persons" with a probability of
                # adding one person. However the difference should be <= than
                # the number of alignment categories.
                - var_aligned: align(fname='al_p_dead_m.csv')
                - temp_aligned: align(fname='al_p_temp.csv')
                - expr_aligned: align(fname='al_p_dead_m.csv',
                                      expressions=[age + 1 - (age + 1) / (age + 1), period])
                - assertTrue(count(temp_aligned != var_aligned) <= 105)
                - assertTrue(count(expr_aligned != var_aligned) <= 105)

                # fixed proportion
                # ----------------
                - fixed_percent_aligned: align(proportions=0.1)
                - num_aligned: count(fixed_percent_aligned)
                - assertTrue(abs(num_aligned - trunc(num_all * 0.1)) <= 1)

                # expr proportion
                # ---------------
                - percent: if(period == 2002, 0.1, 0.2)
                - expr_percent_aligned: align(proportions=percent)
                - num_aligned: count(expr_percent_aligned)
                - target_num: if(period == 2002,
                                 trunc(0.1 * num_all),
                                 trunc(0.2 * num_all))
                - assertTrue(abs(num_aligned - target_num) <= 1)

                # expr ndarray
                # ------------

                # compute % of men for each age
                # Note that we cannot use groupby(age, filter=gender) because
                # in that case we might have age categories missing whereas
                # we want them to be empty instead.
                - men_by_age: groupby(age, expr=count(gender))
                - men_prop_by_age: men_by_age / groupby(age)

                - expr_ndarray_aligned: align(proportions=men_prop_by_age)
                - num_aligned: count(expr_ndarray_aligned)
                # this is correct (and not modulo 1 for each category like
                # other alignment tests) because for each age:
                # expected = len(member_indices) * proportion
                # where len(member_indices) = count(age==x)
                #                             count(age==x and gender)
                #   and proportion          = ---------------------------
                #                             count(age==x)
                #            count(age==x) * count(age==x and gender)
                # expected = ------------------------------------------------
                #            count(age==x)
                #          = count(age==x and gender)
                # and thus expected == int(expected)
                - assertEqual(num_aligned, count(gender))
                - assertEqual(groupby(age, filter=expr_ndarray_aligned),
                              groupby(age, filter=gender))

            test_align_abs:
                - num_all: count()
                - num_women: count(not gender)
                - num_men: count(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align_abs(age,
                                         [10, 20],
                                         expressions=[gender],
                                         possible_values=[[False, True]])
                - assertEqual(count(int_aligned and not gender), 10)
                - assertEqual(count(int_aligned and gender), 20)
                - assertEqual(count(int_aligned), 30)

                # check that older individuals are taken first
                - assertTrue(max(age, filter=gender and not int_aligned)
                             <=
                             min(age, filter=gender and int_aligned))
                - assertTrue(max(age, filter=not gender and not int_aligned)
                             <=
                             min(age, filter=not gender and int_aligned))

                # manual alignment with constant need
                # -----------------------------------
                - aligned: align_abs(age, 10)
                - assertEqual(count(aligned), 10)

                # manual alignment with expr need
                # -------------------------------
                # count(age < 5) is just a number to match, we align over the
                # whole population (ie we do not have a filter)
                - aligned: align_abs(age, count(age < 5))
                - assertEqual(count(aligned), count(age < 5))

                # manual alignment with tuple of exprs need
                # -----------------------------------------
                - aligned: align_abs(age,
                                     (count(not gender and age > 18),
                                      count(gender and age > 20)),
                                     expressions=[gender],
                                     possible_values=[[False, True]])
                - assertEqual(count(aligned and not gender),
                              count(not gender and age > 18))
                - assertEqual(count(aligned and gender),
                              count(gender and age > 20))

                # external file
                # -------------
                - by_gender: align_abs(0, 'al_p_absolute.csv')

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 20)
                - assertEqual(count(by_gender and gender), 30)

                # external file, overridden expressions
                # -------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       expressions=[not gender])

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

                # external file, overridden possible_values
                # -----------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       possible_values=[[True, False]])

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

            test_extexpr:
                - value: extexpr('regr_test_1d.csv')
                - assertEqual(value, eduach * 0.3 + 0.2 * age + 0.1)

            test_logit_score:
                - seed(0)
                - result: logit_score(0.0)
                - seed(0)
                - assertEqual(result, uniform())

                - seed(0)
                - result: logit_score(0.5)
                - seed(0)
                - epsilon: logit(uniform())
                - assertEqual(result, logistic(0.5 - epsilon))

                - seed(0)
                - result: logit_score('regr_test_1d.csv')
                - seed(0)
                - expr: eduach * 0.3 + 0.2 * age + 0.1
                - assertEqual(result, logit_score(expr))
                - assertEqual(result, logistic(expr - epsilon))

            test_logit_regr:
                # equivalent to uniform() > 0.5
                - simple: logit_regr(0.0)
                - fixed_percent: logit_regr(0.0, align=0.5)
                - with_file: logit_regr(0.0, align='al_p_one_dim.csv')

                - with_coef_file: logit_regr('regr_test_1d.csv')
                - with_both_file: logit_regr('regr_test_1d.csv',
                                             align='al_p_one_dim.csv')

            test_cont_regr:
                - show("expr only")
                # -----------------
                - assertEqual(cont_regr(2.4 + 0.22 * age),
                              2.4 + 0.22 * age)

                - show("explicit filter")
                # -----------------------
                - value: cont_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == 2.4 + 0.22 * age,
                            value != value)
                - assertTrue(all(check))

                - show("implicit filter")
                # -----------------------
                - assertEqual(if(gender, cont_regr(2.4 + 0.22 * age), 42.0),
                              if(gender, 2.4 + 0.22 * age, 42.0))

                - show("both implicit and explicit filter")
                # -----------------------------------------
                - value: if(gender,
                            cont_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == 2.4 + 0.22 * age,
                               value != value),
                            value == 42.0)
                - assertTrue(all(check))

                - show("error_var")
                # -----------------
                - err: normal()
                - assertEqual(cont_regr(2.4 + 0.22 * age, error_var='err'),
                              2.4 + 0.22 * age + err)

                - show("mult")
                # ------------
                - value: cont_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (value - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check)) < 0.1)

                - show("both mult and filter (issue 153)")
                # ----------------------------------------

                - value: cont_regr(age, mult=0.5, filter=gender)
                - assertTrue(all(value != value, filter=not gender))
                # this should yield a simple normal random distribution
                - check: (value - age) / 0.5

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check, filter=gender)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check, filter=gender)) < 0.1)

            test_log_regr:
                # expr only
                - assertEqual(log_regr(2.4 + 0.22 * age),
                              exp(2.4 + 0.22 * age))

                # with explicit filter
                - value: log_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == exp(2.4 + 0.22 * age),
                            value != value)
                - assertEqual(count(check), count())

                # with implicit filter
                - assertEqual(if(gender, log_regr(2.4 + 0.22 * age), 42),
                              if(gender, exp(2.4 + 0.22 * age), 42))

                # with both implicit and explicit filter
                - value: if(gender,
                            log_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == exp(2.4 + 0.22 * age),
                               value != value),
                            value == 42.0)
                - assertEqual(count(check), count())

                # with error_var
                - err: normal()
                - assertEqual(log_regr(2.4 + 0.22 * age, error_var='err'),
                              exp(2.4 + 0.22 * age + err))

                # with mult
                - value: log_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (log(value) - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check)) < 0.1)

#            test_uninitialized_var:
#                - result: uninitialized_var

            set_uninitialized_var:
                - uninitialized_var: True

            test_new:
                # with no filter nor number
                - pop: count()
                - new_id: new('person', age=999)
                - assertEqual(count(), 2 * pop)
                - assertEqual(count(age == 999), pop)
                - remove(age == 999)
                - assertEqual(count(), pop)

                # with number
                - new_id: new('person', number=10, age=999)
                - assertEqual(count(), pop + 10)
                - assertEqual(count(age == 999), 10)
                - remove(age == 999)
                - assertEqual(count(), pop)

                # with explicit filter
                - givebirth: not gender and (age >= 16) and (age <= 50)
                - new_id: new('person', filter=givebirth and partner_id != -1,
                              age=0,
                              partner_id=-1,
                              hh_id=hh_id,
                              m_id=id,
                              f_id=partner.id,
                              eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                              gender=choice([True, False], [0.51, 0.49]))

                # with implicit filters
                # unknown father when the mother is < 25 years old (even if
                # she has a partner, so that we can differentiate them.
                - new_id: if(givebirth,
                             if(age < 25,
                                new('person',
                                    age=0,
                                    partner_id=-1,
                                    hh_id=hh_id,
                                    m_id=id,
                                    f_id=-1,
                                    eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                                    gender=choice([True, False], [0.51, 0.49])),
                                new('person',
                                    age=0,
                                    partner_id=-1,
                                    hh_id=hh_id,
                                    m_id=id,
                                    f_id=partner.id,
                                    eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                                    gender=logit_regr(0.0))),
                             -1)

                # both implicit and explicit filters
                - new_id: if(givebirth,
                             new('person', filter=partner_id != -1,
                                 age=0,
                                 partner_id=-1,
                                 hh_id=hh_id,
                                 m_id=id,
                                 f_id=partner.id,
                                 eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                                 gender=choice([True, False], [0.51, 0.49])),
                             -1)

            test_o2m:
                # count
                - nch: children.count()
                - assertEqual(sum(nch), count(mother.id != -1))

                - nch_012: children.count(age <= 12)
                - assertTrue(all(nch_012 <= nch))

                # sum
                - ch_012_age_sum: children.sum(age, age <= 12)
                - ch_012_age2_sum: children.sum(age * 2, age <= 12)
                - assertEqual(ch_012_age2_sum, ch_012_age_sum * 2)

                # with a scalar
                - assertEqual(children.sum(10), nch * 10)

                # avg
                - ch_012_age_avg: children.avg(age, age <= 12)
                - assertNanEqual(ch_012_age_avg, ch_012_age_sum / nch_012)

                # min, max
                - ch_minage: children.min(age)
                - ch_maxage: children.max(age)
                - assertTrue(all(ch_minage <= ch_maxage))
                - assertTrue(sum(ch_minage) < sum(ch_maxage))

                # test that if there is nobody satisfying the filter, it gets
                # the missing value for that type
                - assertEquiv(children.min(age, age > 1000), -1)
                - all_nan: children.min(float_field1, age > 1000)
                - assertTrue(all(all_nan != all_nan))


            test_mixed_links:
                # multi-level
                - assertEqual(partner.partner.age,
                              if(partner_id != -1, age, -1))
                - assertTrue(all(mother.partner.age == father.age,
                                 filter=mother.partner_id == f_id))

                # get
                - assertTrue(all(household.id + 1 == household.get(id + 1),
                                 filter=hh_id != -1))

                # m2o + o2m
                - persons_in_hh: household.get(persons.count())
                - highedu_in_hh: household.get(persons.count(eduach == 4))
                - loweredu_in_hh: household.get(persons.count(eduach < 4))
                - assertEqual(highedu_in_hh + loweredu_in_hh, persons_in_hh)

                # m2o + o2m with filter
                - age_oldest_child: household.get(persons.max(age, age < 18))
                - age_youngest_child: household.get(persons.min(age, age < 18))
                - assertTrue(all(age_oldest_child >= age_youngest_child))

                # m2o + m2o + o2m
                - hh_per_region: household.region.get(households.count())
                - assertTrue(all(hh_per_region > 0))

                # long link chain
                - long: partner.partner.household.region.get(households.count())
                - assertTrue(all(long == hh_per_region,
                                 filter=partner_id != -1))

                # two links using the same column
                - hh_count: household.get(persons.count())
                - hh2_count: household_bis.get(persons.count())
                - assertEqual(hh_count, hh2_count)

#            test_extra_comma:
#                - show('test extra colon'),

             # commented because it raises an exception
#            test_predictor:
#                predictor: plop
#                expr: age

            test_clone:
                - count95: count(age == 95)
                - total: count()
                - clone(filter = age == 95,
                        f_id = id,
                        m_id = id)
                - assertEqual(count(), total + count95)
                - isclone: f_id != -1 and f_id == m_id
                - assertEqual(count(isclone), count95)
                - assertTrue(all(age == 95, filter=isclone))
                - remove(isclone)
                - assertEqual(count(), total)

            marriage:
                - married: partner_id != -1

                - to_marry: (age >= 18) and (age <= 90) and not married
                - avg_age_men: avg(age, filter=to_marry and gender)
                - difficult_match: if(to_marry and not gender,
                                      abs(age - avg_age_men),
                                      nan)
                - workless: not work
                # Note that using links in the score expression slows things
                # down a lot. See https://github.com/liam2/liam2/issues/128.
                - partner_id:
                    if(to_marry,
                       matching(set1filter=not gender,
                                set2filter=gender,
                                score=- 0.4893 * other.age
                                      + 0.0131 * other.age ** 2
                                      - 0.0001 * other.age ** 3
                                      + 0.0467 * (other.age - age)
                                      - 0.0189 * (other.age - age) ** 2
                                      + 0.0003 * (other.age - age) ** 3
                                      - 0.9087 * (other.work and workless)
                                      - 1.3286 * (other.workless and not workless)
                                      - 0.6549 * (other.work and work)
                                      - 0.7939 * ((other.eduach == 3) and TERTIARY_EDU)
                                      - 1.4128 * ((other.eduach == 2) and TERTIARY_EDU)
                                      - 0.8984 * ((other.eduach == 4) and UPPER_SECONDARY_EDU)
                                      - 1.5530 * ((other.eduach == 4) and LOWER_SECONDARY_EDU)
                                      - 0.5451 * ((other.eduach == 2) and LOWER_SECONDARY_EDU)
                                      + 0.0015 * abs(household.num_persons - other.household.num_persons),
                                orderby=difficult_match),
                       partner_id)

                - just_married: to_marry and (partner_id != -1)

                - newhousehold: new('household', filter=just_married and not gender,
                                    start_period=period)
                - hh_id: if(just_married,
                            if(gender, partner.newhousehold, newhousehold),
                            hh_id)

            test_compound:
                - assertEqual(max(min(age, 10)), 10)
                - assertEqual(min(max(age, 20)), 20)

            test_lag:
                - global: show(MINR)
                - global_t: show(MINR[period])

                - lagglobal: show(lag(MINR))
                - lagglobal_period: show(lag(MINR[period]))
                - lagglobal_attr: show(lag(MINR.shape))
                - global_t_1: show(MINR[period - 1])

                - global_t_age: show(MINR[period - age])
                - lagglobal_expr: show(lag(MINR, min(age) + 1))

                # does not work yet. It needs the context to accept a vector
                # of periods instead of a single period
#                - lagglobal_expr_multi: show(lag(MINR, age))

                - lag_age_subscript: show(lag(age[0]))

                - lagavg: show(lag(avg(age)))
                - avglag: show(avg(lag(age)))

                # this fails if we cloned adults: they are missing in last
                # period but have an age != 0 this period
                - assertEqual(lag(age, missing=0), if(age == 0, 0, age - 1))

                - num_birth: count(age == 0)
                # fails with clones
                - assertEqual(count(lag(age) == -1), num_birth)
                - assertEqual(count(lag(age, missing=0) == -1), 0)

                - num1yearold: count(age == 1)
                - assertEqual(count(lag(age, missing=0) == 0),
                              num1yearold + num_birth)

                - assertEqual(lag(age, 2), lag(lag(age)))

                - prev_male: count(lag(MALE))
                - assertEqual(prev_male, count(MALE) - count(age == 0 and MALE))

                - prev_newborns: lag(count(age == 0))
                - assertEqual(prev_newborns, count(age == 1))

                # link in a lag
                # first make sure couples of last period still hold
                - assertTrue(all(partner_id != -1, filter=lag(partner_id) != -1))
                - prev_p_age1: lag(partner.age)
                - prev_p_age2: if(lag(partner_id) != -1, partner.age - 1, -1)
                - assertEqual(prev_p_age1, prev_p_age2)

                # this tests whether id2rownum works correctly for lags of more
                # than one period
                - prev_p_age: lag(partner.age, 2)

                # for clones lag(age, 2) is -1, even if the parent of the clone
                # is alive in period - 2
                - cloned: (m_id == f_id) and (m_id != -1)
#                - assertEqual(if(cloned,
#                                 age - 2,
#                                 lag(age, 2)),
#                              if(period > 2002,
#                                 if(age >= 2, age - 2, -1),
#                                 -1))
                # FIXME: this fails (see issue #146)
                #- g: groupby(agegroup, gender, expr=count(lag(TERTIARY_EDU)))

            test_value_for_period:
                # period is a constant
                - assertEqual(value_for_period(MINR, 2005), 13620.2)
                - assertEqual(value_for_period(age, 2001)[0], 24)

                # period is a scalar expression
                - assertEqual(value_for_period(age, period - 1), lag(age))

            test_duration:
                - show("age > 10", duration(age > 10))
                - show("max(d, 2)", max(duration(age > 10), 2))

                # with a simple boolean variable
                # modify work so that it is not constant for all periods
                - work: choice([False, True])
                # this is just a way to save the work variable
                - work_backup: work and work
                - dur_work: duration(work)
                # check that work was not modified (used to be the case)
                - assertEqual(work, work_backup)
                # check that dur_work is correct
                - assertEqual(dur_work == 0, not work)
                - assertEqual(dur_work == 1, work and not lag(work))
                - assertEqual(dur_work == 2,
                              work and lag(work) and not lag(work, 2))
                - assertEqual(dur_work > 2,
                              work and lag(work) and lag(work, 2))

            test_dump_init:
                - empty_file: csv(fname='empty_file.csv')
                - one_line_header: csv('period', 'id', 'age',
                                       fname='person_ages.csv')
                - two_line_header: csv(['average age', '/'],
                                       ['average age', 'gini'],
                                       fname='person_age_aggregates.csv')

#            test_h5:
#                # mode='a', append=False: replace table in existing file
#                                          (default)
#                # mode='a', append=True: append to existing table
#                                         (append=True implies mode='a')
#                # mode='w': replace the whole file
#                # period is currently stored in array, so we can skip
#                # temporaries and still have it
#                - h5(dump(temporaries=False),
#                     fname='persons.h5', node="/entities/person", append=True)
#                # node defaults to "/entities/{entity}"
#                - h5(dump(), fname='persons.h5', append=True)
#                # fname defaults to output/file
#                - h5(dump(), append=True)
#                # I would be nice to also have a builtin method that does
#                # not need to be defined (something like "__store__"), which
#                # would be equivalent to the current Entity.store_period_data:
#                - h5(dump(temporaries=False), append=True)

            test_dump:
                - expr: csv(dump(gender, age, partner_id, partner.age),
                            suffix='partner_ages')
                - full: csv(dump(), suffix='full')
                - twodumps: csv(dump(gender, age, filter=not gender),
                                'and now something completely different',
                                dump(gender, age, filter=gender),
                                suffix='split_ages')
                # no fname nor suffix
                - csv(dump(age))
                - fname: csv(dump(age), fname='person_ages_{period}.csv')
                # append
                - csv(dump(period, id, age, filter=id < 10, header=False),
                      fname='person_ages.csv', mode='a')
                # test show
                - show(dump(gender, age, filter=id < 10))
                # aggregate and filter (0.6 * is important, otherwise we don't
                # get a 0-d ndarray back, which was the cause of a bug)
                - median_age: 0.6 * median(age)
                - csv(dump(age, avg(age), age > avg(age), median_age,
                           filter=id < 10),
                      suffix='aggregate_filter')
                # dump with no row
                - csv(dump(filter=period == 2100), suffix='norow_scalarfilter')
                - csv(dump(filter=age > 150), suffix='norow_arrayfilter')

            test_csv:
                - show("single expr")
                - csv(avg(age), fname='person_age_aggregates.csv', mode='a')

                - show("single expr with (useless) assign")
                - expr: csv(avg(age),
                            fname='person_age_aggregates.csv', mode='a')

                - show("several exprs")
                - csv(avg(age), gini(age),
                      fname='person_age_aggregates.csv', mode='a')

                - show("empty groupby")
                - csv(groupby(gender, filter=age > 200))

            test_remove:
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))
                - to_remove: age >= 100

                # break links
                - partner_id: if(partner.to_remove, -1, partner_id)
                - f_id: if(father.to_remove, -1, f_id)
                - m_id: if(mother.to_remove, -1, m_id)

                - num_to_remove: count(to_remove)
                - total: count()
                - remove(to_remove)
                - assertTrue(all(0 <= age and age <= 99))
                - assertTrue(all(not to_remove))
                - assertEqual(count(), total - num_to_remove)
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            test_uniform:
                - u: uniform()
                - assertEqual(u.__len__(), count())
                - assertTrue(all(0.0 <= u and u < 1.0))

                - u: uniform(size=200)
                - assertEqual(u.__len__(), 200)

                - u: uniform(filter=gender)
                - assertTrue(all(0.0 <= u and u < 1.0, filter=gender))
                # nan outside the filter
                - assertTrue(all(u != u, filter=not gender))

            test_otherrandom:
                - g: gumbel()
                - g: gumbel(filter=gender)
                # nan outside the filter
                - assertTrue(all(g != g, filter=not gender))
                - p: poisson()
                - assertTrue(all(p >= 0))
                - p: poisson(filter=gender)
                - assertTrue(all(p >= 0, filter=gender))
                - assertTrue(all(p == -1, filter=not gender))
                - mn: multivariate_normal([0, 0], [[1.5, 1], [1, 1.5]])
                - assertEqual(mn.shape, (count(), 2))

            test_all:
                # scalars
                - assertTrue(all(True))
                - assertFalse(all(False))
                # vectors
                - assertTrue(all(id >= 0))
                - assertFalse(all(id < 0))
                - assertFalse(all(id > 100))
                # with a filter
                - assertTrue(all(id >= 0, filter=MALE))
                - assertFalse(all(id < 0, filter=MALE))
                - assertFalse(all(id > 100, filter=MALE))
                - assertTrue(all(MALE, filter=MALE))
                - assertFalse(all(FEMALE, filter=MALE))

            test_any:
                # scalars
                - assertTrue(any(True))
                - assertFalse(any(False))
                # vectors
                - assertTrue(any(id >= 0))
                - assertFalse(any(id < 0))
                - assertTrue(any(id > 100))
                # with a filter
                - assertTrue(any(id >= 0, filter=MALE))
                - assertFalse(any(id < 0, filter=MALE))
                - assertTrue(any(id > 100, filter=MALE))
                - assertTrue(any(MALE, filter=MALE))
                - assertFalse(any(FEMALE, filter=MALE))

            test_count:
                # simple
                - population: count()
                # not very useful but I could not think of something better
                - assertTrue(population >= 0)

                # with a filter
                - qshow(count(MALE))
                - qshow(count(FEMALE))
                - assertEqual(count(MALE) + count(FEMALE), population)
                - assertEqual(count(MALE) + count(FEMALE), population)

            test_sum:
                # simple
                - population_age: sum(age)
                # explicit filter
                - males_age: sum(age, filter=MALE)
                - assertEqual(males_age, sum(age * MALE))
                - females_age: sum(age, filter=FEMALE)
                - qshow(FEMALE)
                - qshow(sum(FEMALE))
                - qshow(age * FEMALE)
                - qshow(sum(age * FEMALE))
                - assertEqual(females_age, sum(age * FEMALE))
                - assertEqual(males_age + females_age, population_age)

                # implicit/contextual filter
                # assign to each man the sum of men ages and to each woman
                # the sum of women ages
                - filtered: if(MALE, sum(age), sum(age))
                - assertEqual(count(filtered == males_age),
                              count(MALE))
                - assertEqual(count(filtered == females_age),
                              count(FEMALE))

                # both implicit and explicit filter
                # assign to each man the sum of men ages and to each woman
                # the sum of women ages
                - age_men_10plus: sum(age, filter=MALE and age >= 10)
                - age_women_20plus: sum(age, filter=FEMALE and age >= 20)
                - test_value: if(MALE, sum(age, filter=age >= 10),
                                       sum(age, filter=age >= 20))
                - assertEqual(count(test_value == age_men_10plus),
                              count(MALE))
                - assertEqual(count(test_value == age_women_20plus),
                              count(FEMALE))

                # nested contextual filter (this is more of a test of nested
                # contextual filters than sum but it makes more sense to
                # have it here anyway)
                - teen: age >= 10 and age < 20
                - test: if(MALE,
                           if(teen, sum(age), sum(age)),
                           sum(age))
                - male_teens_age: sum(age, MALE and teen)
                - male_other_age: sum(age, MALE and not teen)
                - assertEqual(count(test == male_teens_age),
                              count(MALE and teen))
                - assertEqual(count(test == male_other_age),
                              count(MALE and not teen))
                - assertEqual(count(test == females_age),
                              count(FEMALE))

                # with missing
                - assertEqual(sum([1, -1, 2]), 3)
                - assertEqual(sum([1.0, nan, 2.0]), 3.0)

                # with missing but skip_na=False
                - assertEqual(sum([1, -1, 2], skip_na=False), 2)
                - withnan: sum([1.0, nan, 2.0], skip_na=False)
                # fails with numba
#                - assertTrue(withnan != withnan)
                - assertTrue(not (withnan == withnan))

                # with missing and filter
                - assertEqual(sum(if(age > 10, -1, age), filter=gender),
                              sum(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(sum(if(age > 10, nan, f_age), filter=gender),
                              sum(f_age, filter=age <= 10 and gender))

                # bool expr
                - sum_bool: sum([False, True, True])
                - assertEqual(sum_bool, 2)

                # scalar
                # currently fails
#                - assertEqual(sum(2), 2 * count())
                - assertEqual(sum(2, filter=MALE), 2 * count(MALE))

            test_avg:
                # simple
                - assertEqual(avg(age), sum(age) / count())

                # explicit filter
                - assertEqual(avg(age, filter=MALE),
                              sum(age, filter=MALE) / count(MALE))
                - assertEqual(avg(age, filter=FEMALE),
                              sum(age, filter=FEMALE) / count(FEMALE))

                # with missing
                - assertEqual(avg([1.0, nan, 3.0]), 2.0)
                - assertEqual(avg([1, -1, 3]), 2.0)

                # with missing but skip_na=False
                - assertEqual(avg([1, -1, 3], skip_na=False), 1.0)
                - withnan: avg([1.0, nan, 3.0], skip_na=False)
                - assertTrue(withnan != withnan)

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(avg(if(age > 10, -1, age), filter=gender),
                              avg(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(avg(if(age > 10, nan, f_age), filter=gender),
                              avg(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

                # bool expr
                - assertEqual(avg([False, True, True, False]), 0.5)

            test_std:
                # bool expr
                - assertEqual(std([False, True, True, False]), 0.5)

            test_min:
                # simple scalars
                - assertEqual(min([2, 1, 3]), 1)
                - assertEqual(min([2.0, 1.0, 3.0]), 1.0)

                # simple column
                - assertEqual(min(age), 0)

                # explicit filter
                - assertEqual(min(age, filter=age >= 10), 10)

                # with na
                - assertEqual(min([3, -1, 2]), 2)
                - assertEqual(min([3.0, nan, 2.0]), 2.0)

                # with na not skipping
                - assertEqual(min([3, -1, 2], skip_na=False), -1)
                - whnan: min([3.0, nan, 2.0], skip_na=False)
                - assertTrue(whnan != whnan)

                # with na and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(min(if(age > 10, -1, age), filter=gender),
                              min(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(min(if(age > 10, nan, f_age), filter=gender),
                              min(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_max:
                # simple scalars
                - assertEqual(max([2, 1, 3]), 3)
                - assertEqual(max([2.0, 1.0, 3.0]), 3.0)

                # simple column
                - assertTrue(all(age <= max(age)))

                # explicit filter
                - assertEqual(max(age, filter=age <= 20), 20)

                # with na
                - assertEqual(max([3, -1, 2]), 3)
                - assertEqual(max([-3, -1, -2]), -2)
                - assertEqual(max([3.0, nan, 2.0]), 3.0)

                # with na not skipping
                - assertEqual(max([3, -1, 2], skip_na=False), 3)
                - assertEqual(max([-3, -1, -2], skip_na=False), -1)
                - whnan: max([3.0, nan, 2.0], skip_na=False)
                - assertTrue(whnan != whnan)

                # with na and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(max(if(age < 10, -1, age), filter=gender),
                              max(age, filter=age >= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(max(if(age < 10, nan, f_age), filter=gender),
                              max(f_age, filter=age >= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_median:
                # simple without filter
                - median_age: median(age)
                - num_young: count(age < median_age)
                - num_median: count(age == median_age)
                - num_old: count(age > median_age)
                - num_total: count()

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

                # scalar (there is not much point but it should not crash)
                - median_age2: median(median_age)
                - assertEqual(median_age, median_age2)

                # with an explicit filter
                - median_age: median(age, filter=gender)
                - num_young: count(gender and (age < median_age))
                - num_median: count(gender and (age == median_age))
                - num_old: count(gender and (age > median_age))
                - num_total: count(gender)

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

            test_percentile:
                # without filter
                - age_10p: percentile(age, 10)
                - num_young: count(age < age_10p)
                - num_10p: count(age == age_10p)
                - num_old: count(age > age_10p)
                - num_total: count()

                # the + 1 are necessary in case the Nth value is between two
                # different values because in that case, the percentile is a
                # linear approximation of both values, and thus the number of
                # values smaller can be 1 more. Note that if we are between
                # two indices but the values at those two indices is the same
                # we do not have a problem, that is why this problem only
                # triggers rarely in our test because many individuals have
                # the same age.
                # >>> a = [0, 1, 2, 3, 4]
                # >>> np.percentile(a, 25)
                # 1.0
                # >>> np.sum(a < 1.0)
                # 1
                # >>> np.percentile(a, 26)
                # 1.04
                # >>> np.sum(a < 1.04)
                # 2
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

                # with a filter
                - age_10p: percentile(age, 10, filter=gender)
                - num_young: count(gender and (age < age_10p))
                - num_10p: count(gender and (age == age_10p))
                - num_old: count(gender and (age > age_10p))
                - num_total: count(gender)
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

            test_gini:
                # simple expr
                - assertEqual(gini([1, 1, 1]), 0)
                - assertEqual(gini([0, 0, 0, 1]), 0.75)
                - assertEqual(gini([1.0, 0.0, 1.0, 1.0]), 0.25)

                # with missing values
                - assertEqual(gini([0, -1, 1, 0, 0, -1]), 0.75)
                - assertEqual(gini([0.0, nan, 1.0, 0.0, 0.0, nan]), 0.75)

                # with missing values without skipping
                - assertEqual(gini([0, -1, 1, 1, 0], skip_na=False), 2.0)
                - wh_nan: gini([0.0, nan, 1.0, 0.0, nan], skip_na=False)
                - assertTrue(wh_nan != wh_nan)

                # boolean expr
                - assertEqual(gini([False, False, False, True]), 0.75)

                # with an explicit filter
                - show('gini(age)', gini(age))
                - show('gini(age) by sex:',
                       gini(age, filter=MALE),
                       '/',
                       gini(age, filter=FEMALE))

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(gini(if(age > 10, -1, age), filter=gender),
                              gini(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(gini(if(age > 10, nan, f_age), filter=gender),
                              gini(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_choice:
                - intchoice: choice([0, 5, 10], [0.1, 0.2, 0.7])
                - num0: count(intchoice == 0)
                - num5: count(intchoice == 5)
                - num10: count(intchoice == 10)
                - num_total: count()
                - assertEqual(num0 + num5 + num10, num_total)

                # test choices and probabilities being expressions
                - zero: avg(age) - avg(age)

                - p0: zero + 0.1
                - p1: zero + 0.3

                - fchoice: choice([zero, zero + 1.0, zero + 2.0],
                                  [p0, p1, 1.0 - p0 - p1])

                - num0: count(fchoice == 0.0)
                - num1: count(fchoice == 1.0)
                - num2: count(fchoice == 2.0)
                - assertEqual(num0 + num1 + num2, num_total)
                # this assertion can fail but it should occur pretty rarely
                - assertTrue((num0 < num1) and (num1 < num2))

                - show(groupby(choice([zero, zero + 1.0], [p0, 1.0 - p0]),
                               choice([0, 1], [0.3, 0.7]),
                               choice([0, 1])))

                # cases where choice should raise an exception
#                - bad1: choice([0, 1, 2], [0.5, 0.2, 0.1]) # sum < 1
#                - bad2: choice([0, 1, 2], [0.5, 0.4, 0.3]) # sum > 1

                # cases where choice used to print a warning but crashes
                # since we updated numpy.
#                - warn1: choice([0, 1], [0.5, 0.499999])  # sum slightly < 1
#                - warn2: choice([0, 1], [0.5, 0.5000009]) # sum slightly > 1

            test_groupby:
                # 1 dim
                - by_gender: groupby(gender)
                - assertEqual(by_gender,
                              [count(not gender), count(gender)])

                # 2 dim
                - by_agegroup_gender: groupby(agegroup, gender)
                - assertEqual(by_agegroup_gender.ndim, 2)
                - assertEqual(by_agegroup_gender.dim_names,
                              ['agegroup', 'gender'])
                - assertTrue(by_agegroup_gender.row_totals.__len__() > 0)
                - assertEqual(by_agegroup_gender.col_totals,
                              [count(not gender),
                               count(gender),
                               count()])
                - assertEqual(by_agegroup_gender[0],
                              [count(agegroup == -1 and not gender),
                               count(agegroup == -1 and gender)])

                # fails as expected, but if we can fix this, it would be nice
#                - show('groupby scalar', groupby(True, gender))
                # this is currently broken
#                - show('groupby scalar', groupby(avg(age), gender))

                # grouping by expressions (not only simple columns)
                - show(groupby(round(logit_score(0.0), 1)))
                - show('groupby global', groupby(if(gender, 65, WEMRA), gender))

                # with expr=
                - explicit_count: groupby(gender, expr=count())
                - assertEqual(explicit_count,
                              [count(not gender), count(gender)])

                - avg_age: groupby(gender, expr=avg(age))
                - assertEqual(avg_age, [avg(age, filter=not gender),
                                        avg(age, filter=gender)])

                - show('min', groupby(agegroup, expr=min(age)))
                - temp_scalar: avg(age)
                - show('wh scalar variable', groupby(agegroup, expr=temp_scalar * min(age)))

                # with expr= and filter
                - avg_age_work: groupby(gender, expr=avg(age), filter=work)
                - assertEqual(avg_age_work,
                              [avg(age, filter=work and not gender),
                               avg(age, filter=work and gender)])
                - assertEqual(avg_age_work.row_totals,
                              [avg(age, filter=work)])
                # expr=id
                - ids_by_gender: groupby(gender, expr=id, filter=id < 20)
                - assertEqual(ids_by_gender[0], id[id < 20 and not gender])
                - assertEqual(ids_by_gender[1], id[id < 20 and gender])

                # expr=id with the same number in each category (because in
                # that case dtype is int, instead of object)
                - ids_by_id: groupby(id >= 10, expr=id, filter=id < 20)
                - assertEqual(ids_by_id[0], id[id < 10])
                - assertEqual(ids_by_id[1], id[id >= 10 and id < 20])

                # expr=scalar
                - ten_by_gender: groupby(gender, expr=10)
                - assertEqual(ten_by_gender, [10, 10])

                # empty result
                - empty: groupby(gender, filter=age > 200)
                - show(empty)
                - assertEqual(empty, [])
                - empty_percent: groupby(gender, filter=age > 200,
                                         percent=True)
                - assertEqual(empty_percent, [])
                - show(empty_percent)

                # ...
                - num_persons2_percent: show(groupby(agegroup, gender, percent=True))

                - num_persons_weight_percent: show(groupby(agegroup, gender, expr=sum(weight), percent=True))
                - num_persons_csv: csv(groupby(agegroup, gender), suffix='groupby')
                - num_persons3: show(groupby(agegroup, work, gender))

                - ismarried: partner_id != -1
                - num_persons3t: show(groupby(agegroup, gender, ismarried))
                - num_workless: show(groupby(agegroup, gender,
                                          expr=count(not work)))
                - num_married: show(groupby(agegroup, gender,
                                            expr=count(ismarried)))
                - num_partner_work: show(groupby(agegroup, gender,
                                                 expr=count(partner.work)))
                - num_bad_partner: show(groupby(agegroup, gender,
                                                expr=count((partner_id != -1) and (partner.partner.id != id))))
                - agediff: show(groupby(agegroup, gender,
                                        expr=avg(age - if(partner.age == -1, nan, partner.age))))
#                                        expr=avg(abs(age - if(partner.age == -1, nan, partner.age)))))
#                - minmax_age: show(groupby(id / 100, gender, expr=max(age) - min(age)))

                # groupby in expressions
                # ----------------------
                - simple_expr: by_agegroup_gender * 2
                - assertEqual(simple_expr.ndim, 2)
                - assertEqual(simple_expr.dim_names, ['agegroup', 'gender'])
                - assertEqual(simple_expr.row_totals, None)
                - assertEqual(simple_expr.col_totals, None)

                # We cannot use groupby(age, filter=gender) because in that
                # case we might have missing age categories whereas we want
                # them to be empty instead.
                - men_by_age: groupby(age, expr=count(gender))
                - assertEqual(men_by_age.dim_names, ['age'])
                - by_age: groupby(age)
                - assertEqual(by_age.dim_names, ['age'])
                - men_prop_by_age: men_by_age / by_age
                - assertEqual(men_prop_by_age.dim_names, ['age'])

                # this does not trigger the same path than men_prop_by_age
                # (even though both go through ne), but this one creates hidden
                # temporary variables in EvaluableExpression.as_simple_expr
                # while the other does not
                - men_prop2: groupby(age, expr=count(gender)) / groupby(age)
                - assertEqual(men_prop2.dim_names, ['age'])

                # Yet another way to compute it. The division in:
                # count(gender) / count() is done by numexpr and since those are
                # scalars, it returns 0d arrays, so the result used to be
                # (before we special-cased this) an array of 0d arrays, which
                # caused problems when reused in an expression evaluated by
                # numexpr
                - men_prop3: groupby(age, expr=count(gender) / count())

                - assertEqual(men_prop_by_age, men_prop2)
                - assertEqual(men_prop_by_age, men_prop3)
                - men_prop_in_expr: men_prop2 + men_prop3
                - assertEqual(men_prop_in_expr, men_prop2 * 2)

                - min_count_by_gender: min(by_agegroup_gender, axis=0)
                - qshow(min_count_by_gender)
                - assertEqual(min_count_by_gender.shape, (2,))
                - assertEqual(min_count_by_gender.dim_names, None)
                - assertEqual(min_count_by_gender.row_totals, None)
                - assertEqual(min_count_by_gender.col_totals, None)

                - min_count_by_agegroup: min(by_agegroup_gender, axis=1)
                - assertEqual(min_count_by_agegroup.shape, (16,))
                - assertEqual(min_count_by_agegroup.dim_names, None)
                - assertEqual(min_count_by_gender.row_totals, None)
                - assertEqual(min_count_by_gender.col_totals, None)

            show_weight:
                - show("avg weight", avg(weight),
                       "total population", sum(weight))

            test_imported_process:
                - qshow(imported_field1)
                - assertEquiv(imported_field1, -1)
                - assertEqual(imported_field2, age + 2)

            generate:
                - new('person', number=100000,
                      age=randint(0, 98),
                      dead=False,
                      gender=choice([False, True]),
                      work=choice([False, True]),
                      partner_id=-1,
                      f_id=-1,
                      m_id=-1,
                      hh_id=-1)

simulation:
    init:
        - household: [init_region]
        - person: [
#            generate,
            test_init,
            test_dump_init,
            test_remove_init
        ]
#        - household: [setweight, check]
#        # pass 1: weight up to 2
#        - household: [expand]
#        - person: [expand]
#        # pass 2: weights up to 4
#        - household: [expand]
#        - person: [expand]
#        # pass 3: weights up to 8
#        - household: [expand]
#        - person: [expand]
#        # pass 4: weights up to 16
#        - household: [expand]
#        - person: [expand]
#        # pass 5: weights up to 32
#        - household: [expand]
#        - person: [expand]
#
#        - household: [check]

    processes:
        - person: [
#                   bp,
                   compute_agegroup,
                   test_remove,

                   # basic
                   hybrid_temp_global,
                   set_hybrid_temp_global,
                   check_hybrid_temp_global,

                   set_temp_global,
                   check_temp_global,

#                   test_issue120,

                   test_expr,
                   test_trunc,

                   # random
                   test_uniform,
                   test_otherrandom,

                   test_seed,

                   # test the charts before test_new messes the demography
#                   test_charts,

                   # ...
                   test_logit,
                   test_logistic,

                   test_attr,
                   test_subscript,
                   test_call,
#                   test_issue119,
#                   test_issue126,
                   hybrid_test,
                   test_hybrids,

                   test_periodic_globals,
                   test_other_globals,
                   test_globals_nd,

                   test_macro,
                   test_compound,

                   test_while,
                   test_pi_nilakantha,

#                   test_extra_comma,
#                   test_uninitialized_var,

                   # lifecycle
                   test_new,
                   test_clone,

                   # aggregates
                   test_all,
                   test_any,
                   test_count,
                   test_sum,
                   test_avg,
                   test_std,
                   test_min,
                   test_max,
                   test_median,
                   test_percentile,
                   test_gini,

                   # regressions
                   test_extexpr,
                   test_logit_score,
                   test_logit_regr,
                   test_cont_regr,
                   test_log_regr,

                   # temporal
                   test_lag,
                   test_value_for_period,
                   test_duration,

                   # links
                   test_o2m,
                   test_mixed_links,

                   # output
                   test_groupby,
                   test_dump,
                   test_csv,

                   imported_process,
                   test_imported_process,

                   # alignment
                   test_align,
                   test_align_abs,

                   # misc
                   test_choice,
                   show_weight,
        ]
        - household: [composition,
                      test_align_link,
#                      dump_csv_h,
                     ]

#    input:
#        method: void
#        file: none

    output:
        path: output
        file: simulation.h5
    # does not play nicely with recursive functions (because dump wants to
    # access a local variable between the time it is purged from the local scope
    # and the time it is restored from the backup) nor with functions with
    # multiple while loops (because those currently have the same "name".
#    autodump: True
#    autodiff: True

    random_seed: 0
    periods: 2
    logging:
        level: processes
#    timings: False
#    skip_shows: True
