import:
    - imported1.yml
    - imported2.yml

globals:
    periodic:
        path: param/globals.csv
        transposed: True
        fields:
            # PERIOD is implicit

            # WEMRA is defined in imported1.yml. It works even though no "path"
            # key is specified in imported1.yml (as if the periodic table was in
            # the H5 file) and even though it is specified using the "shortcut
            # syntax" for periodic globals because that syntax is expanded
            # before merging imported models, so it just do the right thing.

            - MINR: float
            - MIG_PERCENT: float

    BOOL_CONSTANT1: False
    BOOL_CONSTANT2: True
    INT_CONSTANT1: -1
    INT_CONSTANT2: 42
    FLOAT_CONSTANT1: -1.
    FLOAT_CONSTANT2: 3.1415
    STR_CONSTANT1: "abc"
    STR_CONSTANT2: "a\"b\"c"
    STR_CONSTANT3: "a/b/c"
    STR_CONSTANT4: "a\\b\\c"

    ARRAY:
        type: float

    MIG:
        path: param/mig.csv
        type: float

    CHOICE2D:
        path: param/choice2d.csv
        type: float

    CHOICE2DT:
        path: param/choice2dtransposed.csv
        type: float

    ALIGN_LINK:
        path: align_link.csv
        type: float

    MIG_AUTOINDEX:
        # autoindex: gender
        autoindex: gender, age, period
        path: param/mig.csv
        type: float

    MULTIALIGN:
        path: param/multialign.csv
        type: float

    othertable:
        path: param/othertable.csv
        fields:
            - PERIOD: int
            - INTFIELD: int
            - FLOATFIELD: float

    othertable_noperiod:
        fields:
            - INTFIELD: int

    EXT_EXPR_TEST:
        path: regr_test2.csv
        type: float

    EXT_CHOICE:
        path: ext_choice.csv
        type: float

    ARRAY_DUPE_LABELS:
        path: param/array_dupe_labels.csv
        type: float

    ARRAY_DUPE_LABELS_AUTOINDEX:
        autoindex: axis0, axis1
        path: param/array_dupe_labels.csv
        type: float

entities:
#    test:
#        fields:
#            - test_field: int

    region:
        links:
            households: {type: one2many, target: household, field: region_id}

    household:
        fields:
            - num_persons:  {type: int, initialdata: False}
            - nch:          {type: int, initialdata: False}
            - start_period: {type: int, initialdata: False}
            - clone_id:     {type: int, initialdata: False}
            - weight:       {type: int, initialdata: False}
            - region_id:    {type: int, initialdata: False}

            # period and id are usually implicit, but we include them here
            # anyway for the sake of testing
            - period: int
            - id: int

        links:
            region: {type: many2one, target: region, field: region_id}
            persons: {type: one2many, target: person, field: hh_id}

        processes:
            # utility/test function
            reldiff(v1, v2):
                - return abs(v2 - v1) / v1

            init_region():
                - region_id: choice([0, 1, 2], [0.55, 0.35, 0.10])

            setweight():
                - weight: randint(2, 32)

            expand():
                # note that the while loop solution (for example in create_distrib.yml) does not work in this case
                # because the weight is per household and not per person, thus we have to interleave expand on household
                # and expand on person. Otherwise clone_id is overwritten by the second clone iteration and we can no
                # longer know all household clones. We could expand persons using hh.weight in a loop, then expand hh
                # in a loop to get correct proportions of both but then I don't know how to link cloned persons to their
                # cloned hh instead of the original hh.
                - last_non_clone_id: max(id)
                - toclone: weight > 1
                - clone_id: clone(toclone)
                - is_clone: id > last_non_clone_id
                - weight: if(toclone,
                             trunc((weight + 1) / 2),
                             if(is_clone,
                                trunc(weight / 2),
                                1))

            check():
                - show('min/max weight:', min(weight), max(weight))
                - show('total population:', sum(persons.count()),
                       '/ expanded:', sum(weight * persons.count()))

            composition():
                - num_persons: persons.count()
                - nch: persons.count(age <= 18)

                # TODO: make this work
#                - nch_macro: persons.count(ISCHILD)

            dump_csv_h():
                - csv(dump())

            test_align_link():
                - num_men: persons.count(gender)
                - num_women: persons.count(not gender)
                - num_persons: num_men + num_women

                # kill empty households
                - remove(num_persons == 0)

                - show("total households:", count())
                - total_population: sum(num_persons)
                - total_women: sum(num_women)
                - total_men: sum(num_men)
                - assertEqual(total_population, total_women + total_men)
                - show("total population:", total_population, "=", total_women, "women +", total_men, "men")

                # ALIGN_LINK has one axis: sex=women/men (0.2 for women, 0.22 for men)
                - needed_women: trunc(round(sum(num_women) * ALIGN_LINK[0]))
                - needed_men: trunc(round(sum(num_men) * ALIGN_LINK[1]))
                - needed_total: needed_women + needed_men
                - show("needed:", needed_total, "=", needed_women, "women +", needed_men, "men")

                # without filter
#                - show("\n", groupby(num_men, num_women))
#                - show("\n", groupby(num_men - num_women))
                - aligned: align(persons.count(), ALIGN_LINK, link=persons)

                - women_aligned: sum(num_women, filter=aligned)
                - men_aligned: sum(num_men, filter=aligned)
                - total_aligned: sum(num_persons, filter=aligned)
                - assertEqual(total_aligned, women_aligned + men_aligned)

                - show("women:", women_aligned, "aligned vs", needed_women, "needed")
                - show("men:", men_aligned, "aligned vs", needed_men, "needed")
                - show("total:", total_aligned, "aligned vs", needed_total, "needed")

                # total should be mostly respected
                - assertTrue(reldiff(total_aligned, needed_total) < 0.02)
                # respecting per category totals depends if the distribution in the population match the needed
                # distribution
                - assertTrue(reldiff(women_aligned, needed_women) < 0.05)
                - assertTrue(reldiff(men_aligned, needed_men) < 0.05)

                # with a filter
                - is_candidate: uniform() < 0.8
                - show("candidate households:", count(is_candidate))
                - candidate_total: sum(num_persons, filter=is_candidate)
                - candidate_women: sum(num_women, filter=is_candidate)
                - candidate_men: sum(num_men, filter=is_candidate)
                - assertEqual(candidate_total, candidate_women + candidate_men)
                - show("candidates:", candidate_total, "=", candidate_women, "women +", candidate_men, "men")

                - needed_women: trunc(round(candidate_women * ALIGN_LINK[0]))
                - needed_men: trunc(round(candidate_men * ALIGN_LINK[1]))
                - needed_total: needed_women + needed_men
                - show("needed:", needed_total, "=", needed_women, "women +", needed_men, "men")

                - aligned: align(persons.count(), ALIGN_LINK, link=persons, filter=is_candidate)

                - women_aligned: sum(num_women, filter=aligned)
                - men_aligned: sum(num_men, filter=aligned)
                - total_aligned: sum(num_persons, filter=aligned)
                - assertEqual(total_aligned, women_aligned + men_aligned)

                - show("women:", women_aligned, "aligned vs", needed_women, "needed")
                - show("men:", men_aligned, "aligned vs", needed_men, "needed")
                - show("total:", total_aligned, "aligned vs", needed_total, "needed")

                # total should be mostly respected
                - assertTrue(reldiff(total_aligned, needed_total) < 0.02)
                # respecting per category totals depends if the distribution in the population match the needed
                # distribution
                - assertTrue(reldiff(women_aligned, needed_women) < 0.05)
                - assertTrue(reldiff(men_aligned, needed_men) < 0.05)

            test_align_abs_link():
                - num_persons: persons.count()
                # kill empty households
                - remove(num_persons == 0)

                - total_population: sum(num_persons)
                - show("total:", count(), "households /",
                                 total_population, "persons")

                # MIG_PERCENT is a simple float periodic global
                - num_migrants: total_population * MIG_PERCENT
                - qshow(num_migrants)

                # MIG is a 3d table but we want the 2d table for this period
                - mig_period: MIG[period]

                # Distribute total desired migrants, by age and sex
                - need: num_migrants * mig_period

                # sanity check
                - assertTrue(abs(need.sum() - num_migrants) < 1e-4)

                # without filter
                - aligned_all: align_abs(persons.count(), need,
                                         link=persons, secondary_axis=gender)
                - qshow(count(aligned_all),
                        sum(num_persons, filter=aligned_all))

                # with a filter
                - is_candidate: uniform() < 0.5
                - qshow(count(is_candidate),
                        sum(num_persons, filter=is_candidate))

                - aligned: align_abs(persons.count(), need,
                                     link=persons, secondary_axis=gender,
                                     errors='carry',
                                     filter=is_candidate)
                - qshow(count(aligned),
                        sum(num_persons, filter=aligned))

#                - clone_id: clone(aligned)

                # with pvalues != range(0, X)
                - bchoice: choice([False, True])
                - weird_num: choice([5, 25, 45, 65, 85, 105])
                - weird_need: groupby(bchoice, weird_num, expr=10)
                - show(weird_need)
                - show('by sex', weird_need.sum(axis=1))
                - aligned: align_abs(persons.count(), weird_need,
                                     link=persons, secondary_axis=0,
                                     filter=is_candidate,
                                     expressions=[gender, 5 + trunc(age / 20) * 20])
                - qshow(count(aligned),
                        sum(num_persons, filter=aligned))

    person:
        fields:
            # period and id are implicit
            - age:          int
            # we only use the dead field to remove dead persons in init
            - dead:         bool
            - gender:       bool
            - work:         bool

            - partner_id:   int
            - hh_id:        int
            - f_id:         int
            - m_id:         int

            - weight:       {type: int, initialdata: False}
            - eduach:       {type: int, initialdata: False}
            - agegroup:     {type: int, initialdata: False}
            - float_field1: {type: float, initialdata: False}
            - int_field1:   {type: int, initialdata: False}
            - hybrid_test:  {type: int, initialdata: False}
            - temp_global:  {type: int, initialdata: False, output: False}
            - defaulted_bool_variable:  {type: bool, initialdata: False, default: True}
            - undefaulted_bool_variable:  {type: bool, initialdata: False}
            - defaulted_float_variable:  {type: float, initialdata: False, default: 99.99}
            - undefaulted_float_variable:  {type: float, initialdata: False}
            - defaulted_integer_variable:  {type: int, initialdata: False, default: 99}
            - undefaulted_integer_variable:  {type: int, initialdata: False}

        links:
            partner: {type: many2one, target: person, field: partner_id}
            household: {type: many2one, target: household, field: hh_id}
            household_bis: {type: many2one, target: household, field: hh_id}
            father: {type: many2one, target: person, field: f_id}
            mother: {type: many2one, target: person, field: m_id}
            children: {type: one2many, target: person, field: m_id}

        macros:
            ISCHILD: age < 18

#            BOY: ISCHILD and MALE
#            GIRL: ISCHILD and FEMALE

            MALE: gender
            FEMALE: not gender

            CONSTANT_MACRO: 3

            LOWER_SECONDARY_EDU: eduach == 2
            UPPER_SECONDARY_EDU: eduach == 3
            TERTIARY_EDU: eduach == 4

        # possible transitions & regressions. The actual list used in the
        # simulation must be defined below
        processes:
            bp():
                - breakpoint(2002)

            test_assert():
                # check that assertions function do not raise when their "assertion" is respected
                - assertTrue(True)
                - assertFalse(False)
                - assertEqual(42, 42)
                - assertEqual(42, 43 - 1)
                - assertNanEqual(42, 42)
                - assertNanEqual(42, 43 - 1)
                - assertNanEqual(nan, nan)
                - assertEquiv(42, 42)
                - assertEquiv([42, 42], 42)
                - assertIsClose(1, 1)
                - assertIsClose(1., 1.0000001)

                # check that we get an assertion when trying to access some invalid index and that
                # assertRaises catch it properly
                - assertRaises('IndexError', id[1234567890])

                # check that assertRaises raises NameError when used with an invalid Exception name
                - assertRaises('NameError', assertRaises('YADA', True))

                # check that assertions function raises when their "assertion" is not respected
                - assertRaises('AssertionError', assertTrue(False))
                - assertRaises('AssertionError', assertFalse(True))
                - assertRaises('AssertionError', assertEqual(0, 1))
                - assertRaises('AssertionError', assertNanEqual(0, 1))
                - assertRaises('AssertionError', assertEquiv(0, 1))
                - assertRaises('AssertionError', assertIsClose(0, 1))

                # check that the different ways to pass the msg argument works
                - assertRaises('AssertionError', assertTrue(False, "False is NOT True !"))
                - assertRaises('AssertionError', assertTrue(False, msg="False is NOT True !"))
                - assertRaises('AssertionError', assertTrue(False, msg=("False", "is", "NOT", "True", "!")))
                - assertRaises('AssertionError', assertTrue(all(age > 1000), ("humans do no live that long!", age)))
                - assertRaises('AssertionError', assertTrue(all(age > 1000), msg=("humans do no live that long!", age)))
                - assertRaises('AssertionError', assertTrue(all(age > 1000), msg=dump(age, filter=id < 10)))
                - assertRaises('AssertionError',
                               assertTrue(all(age > 1000), msg=csv(dump(age, filter=id < 10), fname='error_dump.csv')))

                # check that the "usual way" to specify a custom message works for all assert functions
                - assertRaises('AssertionError', assertTrue(False, msg="False is NOT True !"))
                - assertRaises('AssertionError', assertFalse(True, msg="True is NOT False !"))
                - assertRaises('AssertionError', assertEqual(0, 1, msg="0 and 1 are NOT equal !"))
                - assertRaises('AssertionError', assertNanEqual(0, 1, msg="0 and 1 are NOT nan equal !"))
                - assertRaises('AssertionError', assertEquiv(0, 1, msg="0 and 1 are NOT equivalent !"))
                - assertRaises('AssertionError', assertIsClose(0, 1000, msg="0 and 1000 are NOT close !"))

            test_literals():
                - bool1: False
                - assertFalse(bool1)
                - bool2: True
                - assertTrue(bool2)

                - int1: 0
                - assertEqual(int1, 0)
                - int2: -1
                - assertEqual(int2, -1)

                - float1: 0.0
                - assertEqual(float1, 0.0)
                - float2: -1.0
                - assertEqual(float2, -1.0)
                - float3: 0.
                - assertEqual(float3, 0.0)
                - float4: 999.
                - assertEqual(float4, 999.0)

#                - str1: ""
#                - assertEqual(str1, "")
                - str2: "\"a nice string\""
#                - assertEqual(str2, "a nice string")
#                - str3: "a \"string\" with quotes"
#                - assertEqual(str3, "a \"string\" with quotes")
#                - str4: "a 'string' with quotes"
#                - assertEqual(str4, "a 'string' with quotes")

                - list1: []
                - assertEqual(list1, [])
                - list2: [1, 2, 3]
                - assertEqual(list2, [1, 2, 3])

                - dict1: {}
                - assertEqual(dict1, {})
                - dict2: {1: "for the money", 2: "for the show"}
                # we cannot have dict literals in expressions (yaml limitation)
#                - assertEqual(dict2, {1: "for the money", 2: "for the show"})
                - dict2bis: {1: "for the money", 2: "for the show"}
                - assertEqual(dict2, dict2bis)
                - dict3: {"for the money": 1, "for the show": 2}
                # we cannot have dict literals in expressions (yaml limitation)
#                - assertEqual(dict3, {"for the money": 1, "for the show": 2})
                - dict3bis: {"for the money": 1, "for the show": 2}
                - assertEqual(dict3, dict3bis)

            expand():
                - last_non_clone_id: max(id)
                - toclone: household.clone_id != -1
                - clone_id: clone(toclone)

                - is_clone: id > last_non_clone_id

                - hh_id: if(is_clone, household.clone_id, hh_id)
                - m_id: if(is_clone, mother.clone_id, m_id)
                - f_id: if(is_clone, father.clone_id, f_id)
                - partner_id: if(is_clone, partner.clone_id, partner_id)

            test_proc():
                # same name than in the caller function, but should be local
                - temp_var: age * 1
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

            # should raise a warning because it does not make sense (but it
            # is not supported by new syntax)
#            func_only_args_oldsyntax:
#                args: a, b

#            func_only_code_oldsyntax:
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age
#                    - local_var: temp_var * 2
#                    - assertEqual(local_var, age * 2)
#                    # update global variable
#                    - int_field1: age + 1

            func_only_code():
                # same name than in the caller function, but should be local
                - temp_var: age
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

#            func_only_return_oldsyntax:
#                return: age + 1

            func_only_return():
                - return age + 1

#            func_no_args_oldsyntax:
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age
#                    - local_var: temp_var * 2
#                return: local_var * 2

            func_no_args():
                # same name than in the caller function, but should be local
                - temp_var: age
                - local_var: temp_var * 2
                - return local_var * 2

#            func_no_code_oldsyntax:
#                args: a, b
#                return: a + b

            func_no_code(a, b):
                - return a + b

#            func_no_return_oldsyntax:
#                args: a, b
#                code:
#                    # same name than in the caller function, but should be
#                    # local
#                    - temp_var: age * 1
#                    - local_var: temp_var * 2
#                    - assertEqual(local_var, age * 2)
#                    # update global variable
#                    - int_field1: age + 1

            func_no_return(a, b):
                # same name than in the caller function, but should be local
                - temp_var: age * 1
                - local_var: temp_var * 2
                - assertEqual(local_var, age * 2)
                # update global variable
                - int_field1: age + 1

#            func_args_code_result_oldsyntax:
#                args: a, b
#                code:
#                    - result: a + b
#                    - result: result * 2
#                return: result * 2

            func_args_code_result(a, b):
                - result: a + b
                - result: result * 2
                - return result * 2

            func_args_conflict_fields(age):
                - qshow(age)

            # issue 119: function arguments not available in interactive console
            issue119callee(arg):
                - localarg: arg
                # function arguments are not available in the interactive
                # console, but local variables work fine:
                # >>> arg
                # name 'arg' is not defined
                # >>> localarg
                # 1.0
                - show("type 'arg' and see if it is defined")
                - breakpoint()

            # this is an awful hack since we do not have an if control flow
            # keyword yet
            factorial(n):
                - r: 0
                - while n > 1:
                    - r: n * factorial(n - 1)
                    - n: 0
                - while n == 1:
                    - r: 1
                    - n: 0
                - return r

            factorial2(n):
                - while n > 1:
                    - return n * factorial2(n - 1)
                - return n

            factorial3(n):
                - while n <= 1:
                    - return n
                - r: 1
                - while n > 1:
                    - r: r * n
                    - n: n - 1
                - return r

            test_call():
                # 1) no args and no result (concise/old style)
                - temp_var: age * 42
                - int_field1: age + 42
                - assertEqual(int_field1, age + 42)
                - test_proc()
                - assertEqual(int_field1, age + 1)
                # make sure the local variable did not change
                - assertEqual(temp_var, age * 42)

                # 2) no args and no result (verbose/new style)
                - int_field1: age + 42
                - assertEqual(int_field1, age + 42)
                - func_only_code()
                - assertEqual(int_field1, age + 1)
                # make sure the local variable did not change
                - assertEqual(temp_var, age * 42)

#            func_only_args(a, b)
#            func_only_return() # -> age + 1
#            func_no_args() # -> age * 4
#            func_no_code(a, b) # -> a + b
#            func_no_return(a, b) # no return but int_field1: age + 1
#            func_args_code_result:

                - assertEqual(factorial(0), 0)
                - assertEqual(factorial(1), 1)
                - assertEqual(factorial(2), 2)
                - assertEqual(factorial(3), 6)
                - assertEqual(factorial(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial(12), 479001600)

                - assertEqual(factorial2(0), 0)
                - assertEqual(factorial2(1), 1)
                - assertEqual(factorial2(2), 2)
                - assertEqual(factorial2(3), 6)
                - assertEqual(factorial2(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial2(12), 479001600)

                - assertEqual(factorial3(0), 0)
                - assertEqual(factorial3(1), 1)
                - assertEqual(factorial3(2), 2)
                - assertEqual(factorial3(3), 6)
                - assertEqual(factorial3(4), 24)
                # last number to not overflow a 32b int
                - assertEqual(factorial3(12), 479001600)

                # generic call (ndarray methods)
                # without argument
                - assertEqual(age.sum(), sum(age))
                - assertEqual(age.std(), std(age))
                - assertEqual(age.max(), max(age))
                - assertEqual(age.min(), min(age))

                # with constant argument
                - assertEqual(age.min(axis=-1), min(age))

                # with expr argument
                - axis: 0
                - assertEqual(age.min(axis=axis), min(age))

            test_issue119():
                - issue119callee(1.0)

            test_issue120():
                # breakpoint to test issue 120: global temp produces
                # warning in the interactive console. It needs to be
                # called *after* the "temp_global" process !
                - show("type 'age' and see if produces a warning")
                - breakpoint()

            # issue126: prevent function arguments named like fields
            test_issue126():
                - age_backup: age
                - func_args_conflict_fields(age + 10)
                - assertEqual(age, age_backup)

            hybrid_test:
                - hybrid_test: age + 1
                - assertEqual(hybrid_test, age + 1)

            test_hybrids():
                # hybrid = both a variable and a method
                # stored = in fields

                # temporary global (single-expr process) => hybrid
                # * manual call
                - hybrid_temp_global()
                # * in agespine (tested before)
                # * used in expr
                - assertEqual(hybrid_temp_global, age + 10)

                # stored + single-expr process => hybrid
                # * manual call
                - compute_agegroup()
                # * in agespine (tested before)
                # * used in expr (tested in many tests but lets do it here too)
                - local: agegroup * 10
                - assertEqual(local, agegroup * 10)

                # stored + function => hybrid (+ warn?)
                # * manual call
                - hybrid_test()
                # * in agespine (tested before)
                # * used in expr
                - assertEqual(hybrid_test - 1, age)

            # should raise an informative error message in 0.10 at least
#            test_while_oldsyntax:
#                - values: age
#                - while:
#                    cond: min(values) < 5
#                    code:
#                        - values: values + 1


            test_while():
                - values: age
                - while min(values) < 5:
                    - values: values + 1

                - i: 5
                - assertEqual(i, 5)
                - while i:
                    - i: i - 1
                - assertEqual(i, 0)

            # pi using the Nilakantha series
            # pi = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) + ...
            test_pi_nilakantha():
                - numiter: 10
                - pi: 3
                - n: 4
                - d: 2
                - i: 0
                - while i < numiter:
                    - pi: pi + n / (d * (d + 1) * (d + 2))
                    - n: -n
                    - d: d + 2
                    - i: i + 1
                - show("pi approximation after", numiter, "iterations:", pi)

#            test_for:
#                - n: 42
#                # => for is a reserved keyword and can't be used as a
#                #    variable name
#                - for:
#                    variables: i
#                    in: [0, 1, 2, 3]
#                    code:
#                        - show("i:", i, "/ n + i:", n + i)
#                        - show("age:", age)

                 # two variables
#                - for:
#                    variables: index, letter
#                    in: zip([0, 1, 2], ["a", "b", "c"])
#                    code:
#                        - show("index", index, "letter", letter)

             # this will need to be represented by special objects anyway,
             # so let us first do the ugly but easier (to implement) syntax
#            embedded_python:
#                done = False
#                while not done:
#                    age += 1
#                    done = min(age) >= 10

            test_charts():
# commented so that the tests can run without interaction
#                - plot(groupby(age))
                - plot(groupby(age), suffix='test')

                - boxplot(age[gender], age[not gender],
                          fname='bplot1.png&pdf')
                - boxplot((age[gender], age[not gender]),
                          fname='bplot1bis.png')
                - boxplot(groupby(eduach, expr=age, filter=eduach != -1),
                          fname='bplot2.png&pdf')
                - boxplot(groupby(eduach, expr=age, filter=eduach != -1),
                          notch=True, fname='bplot3.png')

                - plot(age, fname='plot01_{entity}_{period}.png')
                - plot(age, 'o', fname='plot02.png')
                - plot(groupby(age), fname='plot03.png&pdf')
                - plot(groupby(age),
                       groupby(age, expr=count(not gender)),
                       groupby(age, expr=count(gender)),
                       fname='plot04.png&pdf')
                - plot((lag(avg(work), 5), lag(avg(work), 4),
                        lag(avg(work), 3), lag(avg(work), 2),
                        lag(avg(work)), avg(work)), fname='plot05.png')
                - plot(groupby(age, gender), fname='plot06.png&pdf')
                - plot(groupby(age, gender), colors=('g', 'b'),
                       fname='plot07.png')
                - plot(groupby(agegroup, gender), styles=['--', '-'],
                       fname='plot08.png')
                - plot(groupby(agegroup, gender),
                       grid=False, linestyle='dashed', marker='o', linewidth=5,
                       fname='plot09.png&pdf')
                - plot(groupby(eduach), 's--', fname='plot10.png')
                - plot(groupby(eduach), 's--', color='g',
                       fname='plot11.png')
                - plot(groupby(agegroup, expr=count(not gender)), 'o--',
                       groupby(agegroup, expr=count(gender)), 's-.',
                       groupby(agegroup), '*-', colors=['r', 'g', 'b'],
                       fname='plot12.png&pdf')

                - stackplot(groupby(eduach), fname='stackplot1.png')
                - stackplot(groupby(age, eduach), fname='stackplot2.png&pdf')
                - stackplot(groupby(eduach, gender),
                            colors=['g', 'b'], baseline='sym',
                            fname='stackplot3.png')
                - stackplot(groupby(age, expr=count(not gender)),
                            groupby(age, expr=count(gender)),
                            fname='stackplot4.png')

                - byage: groupby(age, percent=True)
                - bar(byage, ymax=100, fname='bar1.png')
                - bar(groupby(agegroup), fname='bar2.png&pdf')
                - bar(groupby(agegroup + 1), fname='bar3.png')
                - bar(groupby(agegroup, gender), fname='bar4.png')
                - bar(groupby(agegroup, filter=not gender),
                      groupby(agegroup, filter=gender),
                      fname='bar5.png&pdf')
                - bar(groupby(agegroup, eduach), fname='bar6.png&pdf')
                - bar(groupby(agegroup, eduach), width=0.8, fname='bar7.png')
                # mig_period_women
                - bar(MIG[False, period], fname='bar8.png')

                # axes are currently messed up
                # - barh(groupby(agegroup, eduach))
                # - barh(groupby(agegroup, eduach), height=0.7)

                - pie(groupby(eduach), fname='pie1.png&pdf')
                - pie(groupby(eduach),
                      explode=[0.1, 0, 0],
                      labels=['Lower secondary', 'Upper secondary', 'Tertiary'],
                      fname='pie2.png&pdf')

                # limit number of individuals to get smaller .pdf files
                - num: 200
                - salary: 10000 + uniform(size=num) * 50000
                - area: 3.1415 * (4 + 1.5 * children.count()[:200]) ** 2
                - scatter(age[:num], salary, c=eduach[:num], s=area, grid=True,
                          fname='scatter1.png&pdf')
                # r=expr is equivalent to s=pi * expr ** 2
                - scatter(normal(size=num), normal(size=num), c=age[:num],
                          r=2 ** eduach[:num], alpha=0.8,
                          fname='scatter2.png&pdf')

            test_init():
                - eduach: choice([2, 3, 4], [0.40, 0.35, 0.25])
                - weight: randint(1, 11)
#                - new('person', number=10000000,
#                      age=randint(102),
#                      gender=choice([True, False], [0.5, 0.5]),
#                      work=choice([True, False], [0.5, 0.5]),
#                      partner_id=1)
                # fix incoherent partners
                - bad_partner: partner_id != -1 and partner.partner.id != id
                - partner_id: if(bad_partner, -1, partner_id)
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            test_remove_init():
                # dead True only comes from the input
                - numdead: count(dead)
                - total: count()
                - partner_id: if(partner.dead, -1, partner_id)
                - f_id: if(father.dead, -1, f_id)
                - m_id: if(mother.dead, -1, m_id)
                - remove(dead)
                - assertEqual(count(), total - numdead)
                - assertTrue(all(not dead))
                - assertTrue(all(age >= 0))
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            hybrid_temp_global: age + 10

            set_hybrid_temp_global():
                - hybrid_temp_global: hybrid_temp_global * 2
            check_hybrid_temp_global():
                - assertEqual(hybrid_temp_global, (age + 10) * 2)

            set_temp_global():
                - temp_global: age + 10
            check_temp_global():
                - assertEqual(temp_global, age + 10)

            test_expr():
                - show("count:", count())
                - show("age:", age)
                - show("age + 1:", age + 1)
                - show("age / 10:", age / 10)
                - show("100 / age:", 100 / age)
                - show("age * (1 / 2):", age * (1 / 2))
                - show("clip(age, 10, 50)", clip(age, 10, 50))

                # test we are not having aliases problems
                - backup: age
                # modify it. This occurs in place, because the field is stored
                # in the main array.
                - age: age + 1
                - assertEqual(age, backup + 1)
                - age: backup

            test_trunc():
                - assertTrue(all(age >= 0))
                - diff: (age / 5) - trunc(age / 5)
                - assertTrue(all(0.0 <= diff and diff < 1.0))
                - assertTrue(any(diff > 0.0) and any(diff == 0.0))

# TODO: move these tests somewhere more appropriate
                # this tests the argument-checking code for "_compute"-based
                # functions.
#                - trunc()
#                - trunc(1, 2, 3)

                # this tests the argument-checking code for
                # "NumpyFunction"-based functions
#                - clip(age, 5)
#                - clip(age, 5, 10, 15, 20)

            test_seed():
                - seed(0)
                - value1: uniform()
                - seed(0)
                - value2: uniform()
                - assertEqual(value1, value2)

            test_logit():
                - float_field: age / 120.0
                - assertNanEqual(logit(float_field),
                                 log(float_field / (1.0 - float_field)))

            test_logistic():
                - assertEqual(logistic(age), 1.0 / (1.0 + exp(-age)))
                - float_field: age * 1.0
                - assertEqual(logistic(float_field),
                              1.0 / (1.0 + exp(-float_field)))

            test_attr():
                - assertEqual(age.ndim, 1)

            test_subscript():
                # with constant argument
                # take advantage of the fact that data is ordered by id
                - assertEqual(id[0], min(id))

                # with expr argument
                - newborn: age[age == 0]
                - assertEqual(newborn[0], 0)

                # with slice
                - assertEqual(age[0:1], [age[0]])

                # with expr slice
                - index: trunc(count() / 2)
                - ages: age[index:index+10:2]
                - assertEqual(ages.__len__(), 5)
                - assertEqual(ages[0], age[index])

            test_periodic_globals():
                # implicit global namespace
                # -------------------------
                - fake_wemra: if(period <= 1996, 60,
                              if(period <= 1999, 61,
                              if(period <= 2002, 62,
                              if(period <= 2005, 63,
                              if(period <= 2008, 64, 65)))))
                - fake_wemra_pm1: if(period <= 1997, 60,
                                  if(period <= 2000, 61,
                                  if(period <= 2003, 62,
                                  if(period <= 2006, 63,
                                  if(period <= 2009, 64, 65)))))
                # no index
                - assertEqual(WEMRA, fake_wemra)
                # const_index
                - assertEqual(MINR[2005], 13620.2)
                # (scalar) expr index
                - assertEqual(WEMRA[period - 1], fake_wemra_pm1)

                # Test that the generated variable name is the same for the
                # same global when it is used multiple time (if the period
                # is the same).
                # This is an indirect test because I cannot test this directly
                # yet (this should be a unit test instead).
                # We know numexpr will explode with a ValueError("too many
                # inputs") when there are more than 31 different variables,
                # so if this test passes it means it worked.
                - assertEqual(WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA,
                              WEMRA * 36)

                - globals_in_expr: 1.0 + MINR
                - idx_globals_in_expr: 1.0 + MINR[2002]
                - expr_idx_globals_in_expr: 1.0 + MINR[period - 1]

                # index by a vector
                - yearofbirth: period - age
                - yearofpension: yearofbirth + 65
                - result: MINR[yearofpension]
                - assertEqual(result[0], MINR[yearofpension[0]])

                # test for issue 121 (ie GLOBAL[large_negative] was very slow)
                # In the initial report, it was created with trunc(nan)
                # (= -2147483648).
                - bad_index: if(id >= 0, -2147483648, -1)
                # This takes ~1 minute wh/out the fix and < 1 ms with it.
                - MINR[bad_index]

                # test slices

                # a) slices of constant lengths
                #    (ie. all(stop - start == stop[0] - start[0]))
                #    result is a 2D array: num_individuals x slice_length

                #    1) scalar bounds
                - scalar_bounds: MINR[period:period + 2].sum()
                - assertEqual(scalar_bounds, MINR[period] + MINR[period + 1])

                #    2) scalar start, vector stop
                - scalar_start: MINR[period:age - age + period + 10]
                - assertNanEqual(scalar_start[0][0], MINR[period])
                - assertNanEqual(scalar_start[0][9], MINR[period + 9])

                #    3) vector start, scalar stop
                - scalar_stop: MINR[age - age + period:period + 10]
                - assertNanEqual(scalar_stop[0][0], MINR[period])
                - assertNanEqual(scalar_stop[0][9], MINR[period + 9])

                #    4) vector start, vector stop
                - vector_bounds: MINR[yearofbirth:yearofpension]
                - assertNanEqual(vector_bounds[0],
                                 MINR[yearofbirth[0]:yearofpension[0]])

                # b) slices of varying length
                #    (ie. any(stop - start != stop[0] - start[0]))
                #    result is an IrregularNDArray:
                #    num_individuals x slice lengths
                - yearofpension: yearofbirth + if(gender, 65, WEMRA)

                #    1) scalar start, vector stop
                - scalar_start: MINR[period:yearofpension]
                - assertNanEqual(scalar_start[0], MINR[period:yearofpension[0]])

                #    2) vector start, scalar stop
                # + 1 to not get all nan the first period
                - scalar_stop: MINR[yearofbirth:period + 1]
                - assertNanEqual(scalar_stop[0],
                                 MINR[yearofbirth[0]:period + 1])

                #    3) vector start, vector stop
                - vector_bounds: MINR[yearofbirth:yearofpension]
                - assertNanEqual(vector_bounds[0],
                                 MINR[yearofbirth[0]:yearofpension[0]])

                # test IrregularNDArray methods
                - assertEqual(vector_bounds.prod(axis=1).__len__(), count())
                - assertEqual(vector_bounds.sum(axis=1).__len__(), count())

                # explicit "periodic" namespace
                # -----------------------------
                # no index
                - assertEqual(periodic.WEMRA, fake_wemra)
                # const_index
                - assertEqual(periodic.MINR[2005], 13620.2)
                # expr_index
                - assertEqual(periodic.WEMRA[period - 1], fake_wemra_pm1)
                - vector_idx: periodic.MINR[yearofbirth + 65]

            test_other_globals():
                # with a PERIOD column
                - fake_intfield: if(period <= 1979, -1,
                                 if(period <= 1996, 60,
                                 if(period <= 1999, 61,
                                 if(period <= 2002, 62,
                                 if(period <= 2005, 63,
                                 if(period <= 2008, 64,
                                 if(period <= 2010, 65, -1)))))))
                - assertEqual(othertable.INTFIELD, fake_intfield)
                # expr_index
                - assertEqual(othertable.INTFIELD[period], fake_intfield)

                - baseperiod: 1980
                - assertEqual(othertable_noperiod.INTFIELD[0], 60)
                # expr_index
                - assertEqual(othertable_noperiod.INTFIELD[period - baseperiod],
                              fake_intfield)
                # this is equivalent to INTFIELD[2002], so it is (way) out of
                # bounds but it does not fail, it simply returns "missing"
                # FIXME: it should not be allowed (ie not all global variable
                # should have this "current period if not indexed" behavior.
                - assertEqual(othertable_noperiod.INTFIELD, -1)

            test_globals_nd():
                # MIG is a 3d array: gender-age-period
                # test that MIG was loaded correctly
                - assertEqual(MIG.ndim, 3)
                - assertEqual(MIG.shape, (2, 121, 61))
                - assertEqual(MIG.axes.names, ['gender', 'age', 'period'])

                # binary op with a scalar (need should have the same characteristics than MIG)
                - need: MIG * 2.5
                - assertEqual(need.ndim, 3)
                - assertEqual(need.shape, (2, 121, 61))
                - assertEqual(need.axes.names, ['gender','age', 'period'])

                # binary op with same axes (nd_plus_nd should have the same characteristics than MIG)
                - nd_plus_nd: need + MIG
                - assertEqual(nd_plus_nd.ndim, 3)
                - assertEqual(nd_plus_nd.shape, (2, 121, 61))
                - assertEqual(nd_plus_nd.axes.names, ['gender','age', 'period'])
                - assertIsClose(nd_plus_nd, 3.5 * MIG)

                # binary op with different axes (res should have the same characteristics than MIG)
                - res: need / need.sum('age')
                - assertEqual(res.ndim, 3)
                - assertEqual(res.shape, (2, 121, 61))
                - assertEqual(res.axes.names, ['gender','age', 'period'])
                - assertIsClose(res, res.ratio('age'))

                # let us take the 2d table for this period
                # currently, we need to compute the index manually
                - mig_period: MIG[period]
                - assertEqual(mig_period.ndim, 2)
                - assertEqual(mig_period.shape, (2, 121))
                - assertEqual(mig_period.axes.names, ['gender', 'age'])
                - assertEqual(mig_period.axes.labels.__len__(), 2)

                # test that expressions with more than one dimension (2 in
                # this case) work when the axes from both sides are not the
                # same objects (this is the case in the need and nd_plus_nd
                # tests above)
                - mig_period_bis: MIG[period]
                - mig_period_x2: mig_period + mig_period_bis
                - assertEqual(mig_period_x2, mig_period * 2)

                # should be a 2d table: gender-period
                - need_by_sex_period: need.sum(axis=1)
                - assertEqual(need_by_sex_period.ndim, 2)
                - assertEqual(need_by_sex_period.shape, (2, 61))
                - assertEqual(need_by_sex_period.axes.names, ['gender', 'period'])
                - need_by_sex_period: need.sum('age')
                - assertEqual(need_by_sex_period.ndim, 2)
                - assertEqual(need_by_sex_period.shape, (2, 61))
                - assertEqual(need_by_sex_period.axes.names, ['gender', 'period'])

                # should be a 1d table: gender
                - total_need_by_sex: need_by_sex_period.sum(axis=1)
                - total_need_by_sex: need_by_sex_period.sum('period')
                - assertEqual(total_need_by_sex.ndim, 1)
                - assertEqual(total_need_by_sex.shape, (2,))
                - assertIsClose(total_need_by_sex,
                                [77.6138352312, 74.8861646933])

                # for current period, a 1d table: gender
                - need_by_sex: need_by_sex_period[period]
                - assertEqual(need_by_sex.ndim, 1)
                - assertEqual(need_by_sex.shape, (2,))

                - total_need: need_by_sex.sum()
                - assertEqual(total_need.ndim, 0)
                - qshow(total_need)

                # vector indexes (should produce a non labeled vector)
                # ----------------------------------------------------

                # first, produce a 1 dim LabeledArray to test with
                - need_by_sex20: MIG[20, period]
                - assertEqual(need_by_sex20.ndim, 1)
                - assertEqual(need_by_sex20.shape, (2,))
                - assertEqual(need_by_sex20.axes.names, ['gender'])

                # 1d array[int[:]]
                - need_per_person: need_by_sex20.points[gender]
                - assertEqual(need_per_person.ndim, 1)
                - assertEqual(need_per_person.shape, (count(),))
                #- assertEqual(need_per_person.axes.names, None)
                #- assertEqual(need_per_person.axes.labels, None)

                # 3d array[bool[:], int[:], int]
                - percent_per_person: MIG.points[gender, age, period]
                - assertEqual(percent_per_person.ndim, 1)
                - assertEqual(percent_per_person.shape, (count(),))
                #- assertEqual(percent_per_person.axes.names, None)
                #- assertEqual(percent_per_person.axes.labels, None)
                - assertEqual(percent_per_person.i[0],
                              MIG[gender[0], age[0], period])

                # 3d array[int[:], :, int] -> 2d array
                - indexed: MIG.points[gender, period]
                # make sure we can further subset it
                - i0: indexed.i[0]
                - assertEqual(i0.shape, (121,))

                # use the resulting vector in an expression

                # using a temporary variable
                - remainder_per_person: 1 - percent_per_person
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # via a field: this forces a conversion to a normal
                # (non-labeled) array
                - float_field1: percent_per_person
                - remainder_per_person: 1 - float_field1
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # direct use
                - remainder_per_person: 1 - MIG.points[gender, age, period]
                - assertIsClose(sum(remainder_per_person),
                                count() - sum(percent_per_person))

                # test an expr with two 3d array
                - strange: MIG.points[gender, 0, period] -
                           MIG.points[gender, 1, period]
                - control1: MIG.i[:,0,:] - MIG.i[:,1,:]
                - control2: control1.points[gender, period]
                - assertIsClose(sum(strange), sum(control2))

                # test combination with if() filter, to test whether the
                # contextual filter works properly, especially with bad indices
                - true_: True
                - false_: False

                # scalar key
                # ----------
                - alltrue: age < 1000
                - allfalse: age > 1000

                # array filter
                - test1: if(alltrue, need_by_sex20[False], -1)
                - assertEquiv(test1, need_by_sex20[False])
                - test2: if(allfalse, need_by_sex20[False], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(allfalse, need_by_sex20[2], -1)
                - assertEquiv(test3, -1)

                # scalar filter
                - test1: if(true_, need_by_sex20[False], -1)
                - assertEqual(test1, need_by_sex20[False])
                - test2: if(false_, need_by_sex20[False], -1)
                - assertEqual(test2, -1)
                # bad index
                - test3: if(false_, need_by_sex20[2], -1)
                - assertEqual(test3, -1)

                # array key
                # ---------
                # 0..120 are the only valid indices for need_by_age_men
                - need_by_age_men: MIG[True, period]
                - good_idx: age
                - bad_idx: if(age < 60, age, age + 100)
                - good_res: need_by_age_men.points[good_idx]
                - target: if(age < 60, good_res, 0)

                # array filter
                - test1: if(age < 60, need_by_age_men[good_idx], 0)
                - assertEqual(test1, target)
                - test2: if(age >= 60, 0, need_by_age_men[good_idx])
                - assertEqual(test2, target)
                # bad index
                - test3: if(age < 60, need_by_age_men[bad_idx], 0)
                - assertEqual(test3, target)
                - test4: if(age >= 60, 0, need_by_age_men[bad_idx])
                - assertEqual(test4, target)

                # scalar filter
                - test1: if(true_, need_by_age_men[good_idx], -1)
                - assertEqual(test1, good_res)
                - test2: if(false_, need_by_age_men[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(false_, need_by_age_men[bad_idx], -1)
                - assertEquiv(test3, -1)

                # tuple key
                # ---------
                - good_idx: gender, if(age < 70, age + 20, 0), period
                - bad_idx1: gender, age + 20, period
                - bad_idx2: gender, age, period + 100
                - good_res: MIG.points[good_idx]
                - target: if(age < 70, good_res, -1)

                # array filter
                - test1: if(age < 70, MIG.points[good_idx], -1)
                - assertEqual(test1, target)
                # XXX
                - test2: if(allfalse, MIG.points[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(allfalse, MIG.points[bad_idx1], -1)
                - assertEquiv(test3, -1)
                - test4: if(allfalse, MIG.points[bad_idx2], -1)
                - assertEquiv(test4, -1)

                # scalar filter
                - test1: if(true_, MIG.points[good_idx], -1)
                - assertEqual(test1, good_res)
                - test2: if(false_, MIG.points[good_idx], -1)
                - assertEquiv(test2, -1)
                # bad index
                - test3: if(false_, MIG.points[bad_idx1], -1)
                - assertEquiv(test3, -1)
                - test4: if(false_, MIG.points[bad_idx2], -1)
                - assertEquiv(test4, -1)

                # ambiguous key
                # -------------
                - show(ARRAY_DUPE_LABELS)
                # there is a bug in the loading code, the dtype for both axes are different
#               - ARRAY_DUPE_LABELS.axes.labels
#                [array([False, True], dtype=object), array([False,  True], dtype=bool)]
                # this should fail with an ambiguous error
                # TODO: implement assertRaise
                # does not work because __getitem__ exists on the exprtools.Node/Symbol class
                # => Node.__getattr__ is not called !
                # - assertRaises('ValueError', ARRAY_DUPE_LABELS[1])
                # FIXME13
                # with boolean labels (array_dupe_labels2.csv)
                # - test1: ARRAY_DUPE_LABELS[True]
#                - test1: ARRAY_DUPE_LABELS[X.work[True]]
                # can we make this work?
#                - test1: ARRAY_DUPE_LABELS[work=func(expr1, kw=expr2), gender=True]
                # translated to:
#                - test1: ARRAY_DUPE_LABELS[{'work': func(expr1, kw=expr2), 'gender': True}]
# OR
#                - test1: ARRAY_DUPE_LABELS[X.work[func(expr1, kw=expr2)], X.gender[True]]
                - show(test1)

            test_autoindex():
                # MIG_AUTOINDEX is originally a 3d array: gender-age-period

                # test that MIG_AUTOINDEX has the correct shape: after "autoindexing" by gender, age and period,
                # it should have the same length as the population
                - tmp: MIG_AUTOINDEX
                - assertEqual(tmp.ndim, 1)
                - assertEqual(tmp.shape, (count(),))
                - assertEqual(tmp.axes.names, ['gender_age'])

                # test that indexed behavior is not affected by autoindex
                - explicit1: MIG.points[gender, age, period]
                # FIXME13: this does not work (autoindex happens before .points)
                # unsure it is fixable though. If not, scrap this test.
#                - explicit2: MIG_AUTOINDEX.points[gender, age, period]
#                - assertEqual(explicit2, explicit1)

                # test that the automatic index has the same result than an explicit index
                - assertEqual(tmp, explicit1)

                # with dupe/ambiguous labels
                - axis0: id % 2
                - axis1: (id < median(id)) * 1
                - expected: if(axis0 == 0,
                               if(axis1 == 0, 0.2, 0.3),
                               if(axis1 == 0, 0.4, 0.5))
                - assertEqual(ARRAY_DUPE_LABELS_AUTOINDEX, expected)

            test_macro():
                - ischild: age < 18
                - test_nonmacro1: show(sum(ischild))
                - test_macro1: show(sum(ISCHILD))
#                - breakpoint(2002)

                - age: age + 1

                - test_nonmacro2: show(sum(ischild))
                - show("test sum:", sum(ischild))
                - test_macro2: show(sum(ISCHILD))

                - show('male students', count(MALE and LOWER_SECONDARY_EDU))

#                - show('expr wh missing parenthesis', count(age < 15 & eduach == 2))
                # equivalent to count(age < (15 & eduach) == 2)
                # equivalent to count((age < (15 & eduach)) *and* ((15 & eduach) == 2))
                # calls __nonzero__ on the first part (age < (15 & eduach))
                - show(groupby(eduach, gender))

            compute_agegroup():
                - agegroup: if(age < 50, 5 * trunc(age / 5), 10 * trunc(age / 10))

            test_align():
                - num_all: count()
                - num_women: count(not gender)
                - num_men: count(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align(age,
                                     expressions=[gender],
                                     possible_values=[[False, True]],
                                     proportions=[0.1, 0.2])
                - num_aligned: count(int_aligned)
                - num_aligned_women: count(int_aligned and not gender)
                - num_aligned_men: count(int_aligned and gender)
                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that older individuals are taken first
                - assertTrue(max(age, filter=gender and not int_aligned)
                             <=
                             min(age, filter=gender and int_aligned))
                - assertTrue(max(age, filter=not gender and not int_aligned)
                             <=
                             min(age, filter=not gender and int_aligned))

                # manual alignment on a float column (with nan)
                # ---------------------------------------------
                - nan_age: if(age < 10, nan, age * 1.0)
                - assertEqual(count(nan_age != nan_age), count(age < 10))
                - float_aligned: align(nan_age,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: count(float_aligned)
                - num_aligned_women: count(float_aligned and not gender)
                - num_aligned_men: count(float_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that nan are chosen first
                # we have two different scenarii:
                # 1) we have more "nan" than we need
                #    => we check that all taken are "nan"
                # 2) or we have less "nan" than we need
                #    => we check that all "nan" are taken / aligned
                # and we have to check separately for men and women

                - isnan: nan_age != nan_age

                # women

                # more than 10% women are "nan"
                - morenan: count(not gender and isnan) > num_women * 0.1
                # we use min as a lesser all()
                - all_taken_nan: min(isnan, filter=not gender and float_aligned)
                - all_nan_taken: min(float_aligned,
                                     filter=not gender and isnan)
                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # men

                # more than 20% men are "nan"
                - morenan: count(gender and isnan) > num_men * 0.2
                - all_taken_nan: min(isnan, filter=gender and float_aligned)
                - all_nan_taken: min(float_aligned, filter=gender and isnan)

                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # manual alignment with a constant
                # --------------------------------
                - const_aligned: align(False, filter=age < 10,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: count(const_aligned)
                - num_aligned_women: count(const_aligned and not gender)
                - num_aligned_men: count(const_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(max(id, filter=gender and (age < 10) and
                                               not const_aligned)
                             <=
                             min(id, filter=gender and const_aligned))
                - assertTrue(max(id, filter=not gender and (age < 10) and
                                               not const_aligned)
                             <=
                             min(id, filter=not gender and const_aligned))

                # manual alignment with no score
                # ------------------------------
                - none_aligned: align(filter=age < 10,
                                      expressions=[gender],
                                      possible_values=[[False, True]],
                                      proportions=[0.1, 0.2])
                - num_aligned: count(none_aligned)
                - num_aligned_women: count(none_aligned and not gender)
                - num_aligned_men: count(none_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(max(id, filter=gender and (age < 10) and
                                               not none_aligned)
                             <=
                             min(id, filter=gender and none_aligned))
                - assertTrue(max(id, filter=not gender and (age < 10) and
                                               not none_aligned)
                             <=
                             min(id, filter=not gender and none_aligned))

                # manual alignment with individuals in missing categories
                # -------------------------------------------------------

                - miss_aligned: align(filter=id < 100,
                                      expressions=[20 * trunc(age / 20)],
                                      possible_values=[[0, 20, 60, 80, 100]],
                                      proportions=[0.1, 0.1, 0.1, 0.1, 0.1])
                - num_aligned: count(miss_aligned)
                - assertTrue(num_aligned - 0.1 * num_all < 1.0)

                # alignment with an implicit filter
                # ---------------------------------

                - dead1: if(gender,
                            align(take=age > 95, leave=ISCHILD,
                                  fname='al_p_dead_m.csv'),
                            align(take=age > 95, leave=ISCHILD,
                                  fname='al_p_dead_f.csv'))

                - assertEqual(count(not dead1 and (age > 95)), 0)
                - assertEqual(count(dead1 and ISCHILD), 0)

                # 3d alignment (gender, age, period)
                # ----------------------------------
                - dead2: align(take=age > 95, leave=ISCHILD,
                               fname='al_p_dead.csv')

                - assertTrue(count(dead1 != dead2) <= 105)

                # 2d alignment with period not last
                # ---------------------------------
                - percent_f: if(period <= 2002, 0.2,
                             if(period <= 2003, 0.3, 0.4))
                - percent_m: percent_f + 0.1
                - aligned: align(fname='al_p_period_notlast.csv')

                - theoric_aligned_f: trunc(count(not gender) * percent_f)
                - theoric_aligned_m: trunc(count(gender) * percent_m)
                - diff_f: count(aligned and not gender) - theoric_aligned_f
                - diff_m: count(aligned and gender) - theoric_aligned_m
                - assertTrue((0 <= diff_f) and (diff_f <= 1))
                - assertTrue((0 <= diff_m) and (diff_m <= 1))
                - show('diff_f', diff_f, 'diff_m', diff_m)

                # 1d alignment (period)
                # ---------------------
                - period_only: align(fname='al_p_period_only.csv')
                - num_aligned: count(period_only)
                - target_percent: if(period == 2002, 0.2,
                                  if(period == 2003, 0.3,
                                  0.4))
                - assertTrue(num_aligned - target_percent * num_all < 1.0)

                # 1d alignment (other than period)
                # --------------------------------
                - by_gender: align(fname='al_p_one_dim.csv')

                - num_aligned: count(by_gender)
                - num_aligned_women: count(by_gender and not gender)
                - num_aligned_men: count(by_gender and gender)

                - assertTrue(num_aligned_women - 0.2 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.3 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # align using a temporary variable
                - temp: age + 1

                # these do not produce exactly the same values because of the
                # way we correct for "fractional persons" with a probability of
                # adding one person. However the difference should be <= than
                # the number of alignment categories.
                - var_aligned: align(fname='al_p_dead_m.csv')
                - temp_aligned: align(fname='al_p_temp.csv')
                - expr_aligned: align(fname='al_p_dead_m.csv',
                                      expressions=[age + 1 - (age + 1) / (age + 1), period])
                - assertTrue(count(temp_aligned != var_aligned) <= 105)
                - assertTrue(count(expr_aligned != var_aligned) <= 105)

                # fixed proportion
                # ----------------
                - fixed_percent_aligned: align(proportions=0.1)
                - num_aligned: count(fixed_percent_aligned)
                - assertTrue(abs(num_aligned - trunc(num_all * 0.1)) <= 1)

                # expr proportion
                # ---------------
                - percent: if(period == 2002, 0.1, 0.2)
                - expr_percent_aligned: align(proportions=percent)
                - num_aligned: count(expr_percent_aligned)
                - target_num: if(period == 2002,
                                 trunc(0.1 * num_all),
                                 trunc(0.2 * num_all))
                - assertTrue(abs(num_aligned - target_num) <= 1)

                # expr ndarray
                # ------------

                # compute % of men for each age
                # Note that we cannot use groupby(age, filter=gender) because
                # in that case we might have age categories missing whereas
                # we want them to be empty instead.
                - men_by_age: groupby(age, expr=count(gender))
                - men_prop_by_age: men_by_age / groupby(age)

                - expr_ndarray_aligned: align(proportions=men_prop_by_age)
                - num_aligned: count(expr_ndarray_aligned)
                # this is correct (and not modulo 1 for each category like
                # other alignment tests) because for each age:
                # expected = len(member_indices) * proportion
                # where len(member_indices) = count(age==x)
                #                             count(age==x and gender)
                #   and proportion          = ---------------------------
                #                             count(age==x)
                #            count(age==x) * count(age==x and gender)
                # expected = ------------------------------------------------
                #            count(age==x)
                #          = count(age==x and gender)
                # and thus expected == int(expected)
                - assertEqual(num_aligned, count(gender))
                - assertEqual(groupby(age, filter=expr_ndarray_aligned),
                              groupby(age, filter=gender))

                # filtering on a boolean
                #-----------------------
                - python_bool_filter: False
                - aligned: align(age, proportions=.1, leave = python_bool_filter)

            test_align_abs():
                - num_all: count()
                - num_women: count(not gender)
                - num_men: count(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align_abs(age,
                                         [10, 20],
                                         expressions=[gender],
                                         possible_values=[[False, True]])
                - assertEqual(count(int_aligned and not gender), 10)
                - assertEqual(count(int_aligned and gender), 20)
                - assertEqual(count(int_aligned), 30)

                # check that older individuals are taken first
                - assertTrue(max(age, filter=gender and not int_aligned)
                             <=
                             min(age, filter=gender and int_aligned))
                - assertTrue(max(age, filter=not gender and not int_aligned)
                             <=
                             min(age, filter=not gender and int_aligned))

                # manual alignment with constant need
                # -----------------------------------
                - aligned: align_abs(age, 10)
                - assertEqual(count(aligned), 10)

                # manual alignment with expr need
                # -------------------------------
                # count(age < 5) is just a number to match, we align over the
                # whole population (ie we do not have a filter)
                - aligned: align_abs(age, count(age < 5))
                - assertEqual(count(aligned), count(age < 5))

                # manual alignment with tuple of exprs need
                # -----------------------------------------
                - aligned: align_abs(age,
                                     (count(not gender and age > 18),
                                      count(gender and age > 20)),
                                     expressions=[gender],
                                     possible_values=[[False, True]])
                - assertEqual(count(aligned and not gender),
                              count(not gender and age > 18))
                - assertEqual(count(aligned and gender),
                              count(gender and age > 20))

                # external file
                # -------------
                - by_gender: align_abs(0, 'al_p_absolute.csv')

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 20)
                - assertEqual(count(by_gender and gender), 30)

                # external file, overridden expressions
                # -------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       expressions=[not gender])

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

                # external file, overridden possible_values
                # -----------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       possible_values=[[True, False]])

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

            test_align_abs_sidewalk():
                - num_all: count()
                - num_women: count(not gender)
                - num_men: count(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align_abs(logistic(age),
                                         [10, 20],
                                         expressions=[gender],
                                         possible_values=[[False, True]],
                                         method='sidewalk')
                - assertEqual(count(int_aligned and not gender), 10)
                - assertEqual(count(int_aligned and gender), 20)
                - assertEqual(count(int_aligned), 30)

                # manual alignment with constant need
                # -----------------------------------
                - aligned: align_abs(logistic(age), 10, method='sidewalk')
                - assertEqual(count(aligned), 10)

                # manual alignment with expr need
                # -------------------------------
                # count(age < 5) is just a number to match, we align over the
                # whole population (ie we do not have a filter)
                - aligned: align_abs(logistic(age), count(age < 5),
                                     method='sidewalk')
                - assertEqual(count(aligned), count(age < 5))

                # manual alignment with tuple of exprs need
                # -----------------------------------------
                - aligned: align_abs(logistic(age),
                                     (count(not gender and age > 18),
                                      count(gender and age > 20)),
                                     expressions=[gender],
                                     possible_values=[[False, True]],
                                     method='sidewalk')
                - assertEqual(count(aligned and not gender),
                              count(not gender and age > 18))
                - assertEqual(count(aligned and gender),
                              count(gender and age > 20))

                # external file
                # -------------
                - by_gender: align_abs(logistic(age), 'al_p_absolute.csv',
                                       method='sidewalk')

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 20)
                - assertEqual(count(by_gender and gender), 30)

                # external file, overridden expressions
                # -------------------------------------
                - by_gender: align_abs(logistic(age), 'al_p_absolute.csv',
                                       expressions=[not gender],
                                       method='sidewalk')

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

                # external file, overridden possible_values
                # -----------------------------------------
                - by_gender: align_abs(logistic(age), 'al_p_absolute.csv',
                                       possible_values=[[True, False]],
                                       method='sidewalk')

                - assertEqual(count(by_gender), 50)
                - assertEqual(count(by_gender and not gender), 30)
                - assertEqual(count(by_gender and gender), 20)

            test_extexpr():
                # fields
                - value: extexpr('regr_test_1d.csv')
                - assertEqual(value, 0.3 * eduach + 0.2 * age + 0.1)

                # gender, fields
                - value: extexpr('regr_test2.csv')
                - assertEqual(value, if(gender,
                                        0.4 * age + 0.5 * gender + 0.6,
                                        0.3 * age + 0.2 * gender + 0.1))

                # fields, gender
                - value: extexpr('regr_test3.csv')
                - assertEqual(value, if(gender,
                                        0.34 * eduach + 0.23 * age + 0.12,
                                        0.33 * eduach + 0.22 * age + 0.11))
                # fields, gender, period
                - value: extexpr('regr_test4.csv')
                - pair_period: if(gender, 0.34 * eduach + 0.23 * age + 0.12,
                                          0.33 * eduach + 0.22 * age + 0.11)
                - odd_period: if(gender, 0.12 * eduach + 0.22 * age + 0.32,
                                         0.11 * eduach + 0.21 * age + 0.31)
                - control_value: if(period % 2 == 0, pair_period, odd_period)
                - assertEqual(value, control_value)

                # gender, fields via global
                - value: extexpr(EXT_EXPR_TEST)
                - assertEqual(value, if(gender,
                                        0.4 * age + 0.5 * gender + 0.6,
                                        0.3 * age + 0.2 * gender + 0.1))

                # gender, fields via expression
                - value: extexpr(EXT_EXPR_TEST.sum('gender'))
                - assertEqual(value, 0.7 * age + 0.7 * gender + 0.7)

                # fields, gender, work (ie ambiguous labels)
                - value: extexpr('regr_test5.csv')
                - expected_ifwork: if(gender, 0.12 * eduach + 0.22 * age + 0.32,
                                              0.11 * eduach + 0.21 * age + 0.31)
                - expected_nowork: if(gender, 0.34 * eduach + 0.23 * age + 0.12,
                                              0.33 * eduach + 0.22 * age + 0.11)
                - expected: if(work, expected_ifwork, expected_nowork)
                - assertEqual(value, expected)

            test_logit_score():
                - seed(0)
                - result: logit_score(0.0)
                - seed(0)
                - assertEqual(result, uniform())

                - seed(0)
                - result: logit_score(0.5)
                - seed(0)
                - epsilon: logit(uniform())
                - assertEqual(result, logistic(0.5 - epsilon))

                - seed(0)
                - result: logit_score('regr_test_1d.csv')
                - seed(0)
                - expr: eduach * 0.3 + 0.2 * age + 0.1
                - assertEqual(result, logit_score(expr))
                - assertEqual(result, logistic(expr - epsilon))

            test_logit_regr():
                # equivalent to uniform() > 0.5
                - simple: logit_regr(0.0)
                - fixed_percent: logit_regr(0.0, align=0.5)
                - with_file: logit_regr(0.0, align='al_p_one_dim.csv')

                - with_coef_file: logit_regr('regr_test_1d.csv')
                - with_both_file: logit_regr('regr_test_1d.csv',
                                             align='al_p_one_dim.csv')

            test_cont_regr():
                - show("expr only")
                # -----------------
                - assertEqual(cont_regr(2.4 + 0.22 * age),
                              2.4 + 0.22 * age)

                - show("explicit filter")
                # -----------------------
                - value: cont_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == 2.4 + 0.22 * age,
                            value != value)
                - assertTrue(all(check))

                - show("implicit filter")
                # -----------------------
                - assertEqual(if(gender, cont_regr(2.4 + 0.22 * age), 42.0),
                              if(gender, 2.4 + 0.22 * age, 42.0))

                - show("both implicit and explicit filter")
                # -----------------------------------------
                - value: if(gender,
                            cont_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == 2.4 + 0.22 * age,
                               value != value),
                            value == 42.0)
                - assertTrue(all(check))

                - show("error_var")
                # -----------------
                - err: normal()
                - assertEqual(cont_regr(2.4 + 0.22 * age, error_var='err'),
                              2.4 + 0.22 * age + err)

                - show("mult")
                # ------------
                - value: cont_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (value - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check)) < 0.1)

                - show("both mult and filter (issue 153)")
                # ----------------------------------------

                - value: cont_regr(age, mult=0.5, filter=gender)
                - assertTrue(all(value != value, filter=not gender))
                # this should yield a simple normal random distribution
                - check: (value - age) / 0.5

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check, filter=gender)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check, filter=gender)) < 0.1)

            test_log_regr():
                # expr only
                - assertEqual(log_regr(2.4 + 0.22 * age),
                              exp(2.4 + 0.22 * age))

                # with explicit filter
                - value: log_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == exp(2.4 + 0.22 * age),
                            value != value)
                - assertEqual(count(check), count())

                # with implicit filter
                - assertEqual(if(gender, log_regr(2.4 + 0.22 * age), 42),
                              if(gender, exp(2.4 + 0.22 * age), 42))

                # with both implicit and explicit filter
                - value: if(gender,
                            log_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == exp(2.4 + 0.22 * age),
                               value != value),
                            value == 42.0)
                - assertEqual(count(check), count())

                # with error_var
                - err: normal()
                - assertEqual(log_regr(2.4 + 0.22 * age, error_var='err'),
                              exp(2.4 + 0.22 * age + err))

                # with mult
                - value: log_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (log(value) - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - avg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - std(check)) < 0.1)

#            test_uninitialized_var:
#                - result: uninitialized_var

            set_uninitialized_var():
                - uninitialized_var: True

            test_new():
                # with no filter nor number
                - pop: count()
                - child_id: new('person', age=999)
                # child_id is set to the child id for the "parent" individual and -1
                # for others, including the child itself
                - isnew: child_id == -1
                - assertEqual(count(), 2 * pop)
                - assertEqual(count(isnew), pop)
                # test the value of a field set explicitly
                - assertTrue(all(age == 999, filter=isnew))
                - assertTrue(all(age != 999, filter=not isnew))
                # test values of fields not set explicitly
                - assertTrue(all(defaulted_bool_variable, filter=isnew))
                - assertTrue(all(not undefaulted_bool_variable, filter=isnew))
                - assertTrue(all(defaulted_integer_variable == 99,
                                 filter=isnew))
                - assertTrue(all(undefaulted_integer_variable == -1,
                                 filter=isnew))
                - assertTrue(all(defaulted_float_variable == 99.99,
                                 filter=isnew))
                - assertTrue(all(undefaulted_float_variable !=
                                 undefaulted_float_variable,
                                 filter=isnew))
                - remove(isnew)
                - assertEqual(count(), pop)

                # with number
                - new_id: new('person', number=10, age=999)
                - assertEqual(count(), pop + 10)
                - assertEqual(count(age == 999), 10)
                - remove(age == 999)
                - assertEqual(count(), pop)

                - givebirth: not gender and (age >= 16) and (age <= 50) and uniform() < 0.1

                # with implicit filters
                # unknown father when the mother is < 25 years old (even if
                # she has a partner, so that we can differentiate them.
                - child_id: if(givebirth,
                               if(age < 25,
                                  new('person',
                                      age=999,
                                      partner_id=-1,
                                      hh_id=hh_id,
                                      m_id=id,
                                      f_id=-1,
                                      eduach=choice([2, 3, 4],
                                                    [0.40, 0.35, 0.25]),
                                      gender=choice([True, False],
                                                    [0.51, 0.49])),
                                  new('person',
                                      age=999,
                                      partner_id=-1,
                                      hh_id=hh_id,
                                      m_id=id,
                                      f_id=partner.id,
                                      eduach=choice([2, 3, 4],
                                                    [0.40, 0.35, 0.25]),
                                      gender=logit_regr(0.0))),
                               -1)

                # both implicit and explicit filters
                - child_id: if(givebirth,
                               new('person', filter=partner_id != -1,
                                   age=999,
                                   partner_id=-1,
                                   hh_id=hh_id,
                                   m_id=id,
                                   f_id=partner.id,
                                   eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                                   gender=choice([True, False], [0.51, 0.49])),
                               -1)
                - remove(age == 999)
                - assertEqual(count(), pop)

                # with explicit filter
                - child_id: new('person', filter=givebirth and partner_id != -1,
                                age=0,
                                partner_id=-1,
                                hh_id=hh_id,
                                m_id=id,
                                f_id=partner.id,
                                eduach=choice([2, 3, 4], [0.40, 0.35, 0.25]),
                                gender=choice([True, False], [0.51, 0.49]))

            test_o2m():
                # count
                - nch: children.count()
                - assertEqual(sum(nch), count(mother.id != -1))

                - nch_012: children.count(age <= 12)
                - assertTrue(all(nch_012 <= nch))

                # sum
                - ch_012_age_sum: children.sum(age, age <= 12)
                - ch_012_age2_sum: children.sum(age * 2, age <= 12)
                - assertEqual(ch_012_age2_sum, ch_012_age_sum * 2)

                # with a scalar
                - assertEqual(children.sum(10), nch * 10)

                # avg
                - ch_012_age_avg: children.avg(age, age <= 12)
                - assertNanEqual(ch_012_age_avg, ch_012_age_sum / nch_012)

                # min, max
                - ch_minage: children.min(age)
                - ch_maxage: children.max(age)
                - assertTrue(all(ch_minage <= ch_maxage))
                - assertTrue(sum(ch_minage) < sum(ch_maxage))

                # test that if there is nobody satisfying the filter, it gets
                # the missing value for that type
                - assertEquiv(children.min(age, age > 1000), -1)
                - all_nan: children.min(float_field1, age > 1000)
                - assertTrue(all(all_nan != all_nan))

            test_mixed_links():
                # multi-level
                - assertEqual(partner.partner.age,
                              if(partner_id != -1, age, -1))
                - assertTrue(all(mother.partner.age == father.age,
                                 filter=mother.partner_id == f_id))

                # get
                - assertTrue(all(household.id + 1 == household.get(id + 1),
                                 filter=hh_id != -1))

                # m2o + o2m
                - persons_in_hh: household.get(persons.count())
                - highedu_in_hh: household.get(persons.count(eduach == 4))
                - loweredu_in_hh: household.get(persons.count(eduach < 4))
                - assertEqual(highedu_in_hh + loweredu_in_hh, persons_in_hh)

                # m2o + o2m with filter
                - age_oldest_child: household.get(persons.max(age, age < 18))
                - age_youngest_child: household.get(persons.min(age, age < 18))
                - assertTrue(all(age_oldest_child >= age_youngest_child))

                # m2o + m2o + o2m
                - hh_per_region: household.region.get(households.count())
                - assertTrue(all(hh_per_region > 0))

                # long link chain
                - long: partner.partner.household.region.get(households.count())
                - assertTrue(all(long == hh_per_region,
                                 filter=partner_id != -1))

                # two links using the same column
                - hh_count: household.get(persons.count())
                - hh2_count: household_bis.get(persons.count())
                - assertEqual(hh_count, hh2_count)

#            test_extra_comma:
#                - show('test extra colon'),

             # commented because it raises an exception
#            test_predictor:
#                predictor: plop
#                expr: age

            test_clone():
                - count95: count(age == 95)
                - total: count()
                - clone(filter = age == 95,
                        f_id = id,
                        m_id = id)
                - assertEqual(count(), total + count95)
                - isclone: f_id != -1 and f_id == m_id
                - assertEqual(count(isclone), count95)
                - assertTrue(all(age == 95, filter=isclone))
                - remove(isclone)
                - assertEqual(count(), total)

            marriage():
                - married: partner_id != -1

                - to_marry: (age >= 18) and (age <= 90) and not married
                - avg_age_men: avg(age, filter=to_marry and gender)
                - difficult_match: if(to_marry and not gender,
                                      abs(age - avg_age_men),
                                      nan)
                - workless: not work
                # Note that using links in the score expression slows things
                # down a lot. See https://github.com/liam2/liam2/issues/128.
                - partner_id:
                    if(to_marry,
                       matching(set1filter=not gender,
                                set2filter=gender,
                                score=- 0.4893 * other.age
                                      + 0.0131 * other.age ** 2
                                      - 0.0001 * other.age ** 3
                                      + 0.0467 * (other.age - age)
                                      - 0.0189 * (other.age - age) ** 2
                                      + 0.0003 * (other.age - age) ** 3
                                      - 0.9087 * (other.work and workless)
                                      - 1.3286 * (other.workless and not workless)
                                      - 0.6549 * (other.work and work)
                                      - 0.7939 * ((other.eduach == 3) and TERTIARY_EDU)
                                      - 1.4128 * ((other.eduach == 2) and TERTIARY_EDU)
                                      - 0.8984 * ((other.eduach == 4) and UPPER_SECONDARY_EDU)
                                      - 1.5530 * ((other.eduach == 4) and LOWER_SECONDARY_EDU)
                                      - 0.5451 * ((other.eduach == 2) and LOWER_SECONDARY_EDU)
                                      + 0.0015 * abs(household.num_persons - other.household.num_persons),
                                orderby=difficult_match),
                       partner_id)

                - just_married: to_marry and (partner_id != -1)

                - newhousehold: new('household', filter=just_married and not gender,
                                    start_period=period)
                - hh_id: if(just_married,
                            if(gender, partner.newhousehold, newhousehold),
                            hh_id)

            test_compound():
                - assertEqual(max(min(age, 10)), 10)
                - assertEqual(min(max(age, 20)), 20)

            test_lag():
                - global: show(MINR)
                - global_t: show(MINR[period])

                - lagglobal: show(lag(MINR))
                - lagglobal_period: show(lag(MINR[period]))
                - lagglobal_attr: show(lag(MINR.shape))
                - global_t_1: show(MINR[period - 1])

                - global_t_age: show(MINR[period - age])
                - lagglobal_expr: show(lag(MINR, min(age) + 1))

                # does not work yet. It needs the context to accept a vector
                # of periods instead of a single period
#                - lagglobal_expr_multi: show(lag(MINR, age))

                - lag_age_subscript: show(lag(age[0]))

                - lagavg: show(lag(avg(age)))
                - avglag: show(avg(lag(age)))

                # this fails if we cloned adults: they are missing in last
                # period but have an age != 0 this period
                - assertEqual(lag(age, missing=0), if(age == 0, 0, age - 1))

                - num_birth: count(age == 0)
                # fails with clones
                - assertEqual(count(lag(age) == -1), num_birth)
                - assertEqual(count(lag(age, missing=0) == -1), 0)

                - num1yearold: count(age == 1)
                - assertEqual(count(lag(age, missing=0) == 0),
                              num1yearold + num_birth)

                - assertEqual(lag(age, 2), lag(lag(age)))

                - prev_male: count(lag(MALE))
                - assertEqual(prev_male, count(MALE) - count(age == 0 and MALE))

                - prev_newborns: lag(count(age == 0))
                - assertEqual(prev_newborns, count(age == 1))

                # link in a lag
                # first make sure couples of last period still hold
                - assertTrue(all(partner_id != -1, filter=lag(partner_id) != -1))
                - prev_p_age1: lag(partner.age)
                - prev_p_age2: if(lag(partner_id) != -1, partner.age - 1, -1)
                - assertEqual(prev_p_age1, prev_p_age2)

                # this tests whether id2rownum works correctly for lags of more
                # than one period
                - prev_p_age: lag(partner.age, 2)

                # for clones lag(age, 2) is -1, even if the parent of the clone
                # is alive in period - 2
                - cloned: (m_id == f_id) and (m_id != -1)
#                - assertEqual(if(cloned,
#                                 age - 2,
#                                 lag(age, 2)),
#                              if(period > 2002,
#                                 if(age >= 2, age - 2, -1),
#                                 -1))
                # FIXME: this fails (see issue #146)
                #- g: groupby(agegroup, gender, expr=count(lag(TERTIARY_EDU)))

            test_lag_o2m():
                # this mostly tests that DiskBackedArrays work as expected
                - past_nch: lag(children.count(), 2)
                # this does not test much but I cannot think of anything more
                # precise that is guaranteed to be True
                - assertTrue(all(past_nch >= -1))
                - assertTrue(all(past_nch < 50))

            test_value_for_period():
                # period is a constant
                - assertEqual(value_for_period(MINR, 2005), 13620.2)
                - assertEqual(value_for_period(age, 2001)[0], 24)

                # period is a scalar expression
                - assertEqual(value_for_period(age, period - 1), lag(age))

            test_duration():
                - show("age > 10", duration(age > 10))
                - show("max(d, 2)", max(duration(age > 10), 2))

                # with a simple boolean variable
                # modify work so that it is not constant for all periods
                - work: choice([False, True])
                # this is just a way to save the work variable
                - work_backup: work and work
                - dur_work: duration(work)
                # check that work was not modified (used to be the case)
                - assertEqual(work, work_backup)
                # check that dur_work is correct
                - assertEqual(dur_work == 0, not work)
                - assertEqual(dur_work == 1, work and not lag(work))
                - assertEqual(dur_work == 2,
                              work and lag(work) and not lag(work, 2))
                - assertEqual(dur_work > 2,
                              work and lag(work) and lag(work, 2))

            test_dump_init():
                - empty_file: csv(fname='empty_file.csv')
                - one_line_header: csv('period', 'id', 'age',
                                       fname='person_ages.csv')
                - two_line_header: csv(['average age', '/'],
                                       ['average age', 'gini'],
                                       fname='person_age_aggregates.csv')

#            test_h5:
#                # mode='a', append=False: replace table in existing file
#                                          (default)
#                # mode='a', append=True: append to existing table
#                                         (append=True implies mode='a')
#                # mode='w': replace the whole file
#                # period is currently stored in array, so we can skip
#                # temporaries and still have it
#                - h5(dump(temporaries=False),
#                     fname='persons.h5', node="/entities/person", append=True)
#                # node defaults to "/entities/{entity}"
#                - h5(dump(), fname='persons.h5', append=True)
#                # fname defaults to output/file
#                - h5(dump(), append=True)
#                # I would be nice to also have a builtin method that does
#                # not need to be defined (something like "__store__"), which
#                # would be equivalent to the current Entity.store_period_data:
#                - h5(dump(temporaries=False), append=True)

            test_dump():
                - expr: csv(dump(gender, age, partner_id, partner.age),
                            suffix='partner_ages')
                - full: csv(dump(), suffix='full')
                - twodumps: csv(dump(gender, age, filter=not gender),
                                'and now something completely different',
                                dump(gender, age, filter=gender),
                                suffix='split_ages')
                # no fname nor suffix
                - csv(dump(age))
                - fname: csv(dump(age), fname='person_ages_{period}.csv')
                # append
                - csv(dump(period, id, age, filter=id < 10, header=False),
                      fname='person_ages.csv', mode='a')

                # limit only
                - csv(dump(period, id, age, limit=10), fname='dump_limit.csv')
                # limit and filter (more statisfying the filter than limit)
                - csv(dump(period, id, age, filter=id >= 10, limit=10),
                      fname='dump_limit.csv', mode='a')
                # limit and filter (more statisfying the filter than limit)
                - csv(dump(period, id, age, filter=id < 5, limit=10),
                      fname='dump_limit.csv', mode='a')

                # test show
                - show(dump(gender, age, filter=id < 10))
                # aggregate and filter (0.6 * is important, otherwise we don't
                # get a 0-d ndarray back, which was the cause of a bug)
                - median_age: 0.6 * median(age)
                - csv(dump(age, avg(age), age > avg(age), median_age,
                           filter=id < 10),
                      suffix='aggregate_filter')
                # dump with no row
                - csv(dump(filter=period == 2100), suffix='norow_scalarfilter')
                - csv(dump(filter=age > 150), suffix='norow_arrayfilter')

            test_csv():
                - show("single expr")
                - csv(avg(age), fname='person_age_aggregates.csv', mode='a')

                - show("single expr with (useless) assign")
                - expr: csv(avg(age),
                            fname='person_age_aggregates.csv', mode='a')

                - show("several exprs")
                - csv(avg(age), gini(age),
                      fname='person_age_aggregates.csv', mode='a')

                - show("empty groupby")
                - csv(groupby(gender, filter=age > 200))

            test_remove():
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))
                - to_remove: age >= 100

                # break links
                - partner_id: if(partner.to_remove, -1, partner_id)
                - f_id: if(father.to_remove, -1, f_id)
                - m_id: if(mother.to_remove, -1, m_id)

                - num_to_remove: count(to_remove)
                - total: count()
                - remove(to_remove)
                - assertTrue(all(0 <= age and age <= 99))
                - assertTrue(all(not to_remove))
                - assertEqual(count(), total - num_to_remove)
                - assertTrue(all(partner.partner.id == id,
                                 filter=partner_id != -1))

            test_uniform():
                - u: uniform()
                - assertEqual(u.__len__(), count())
                - assertTrue(all(0.0 <= u and u < 1.0))

                - u: uniform(size=200)
                - assertEqual(u.__len__(), 200)

                - u: uniform(filter=gender)
                - assertTrue(all(0.0 <= u and u < 1.0, filter=gender))
                # nan outside the filter
                - assertTrue(all(u != u, filter=not gender))

            test_otherrandom():
                - g: gumbel()
                - g: gumbel(filter=gender)
                # nan outside the filter
                - assertTrue(all(g != g, filter=not gender))
                - p: poisson()
                - assertTrue(all(p >= 0))
                - p: poisson(filter=gender)
                - assertTrue(all(p >= 0, filter=gender))
                - assertTrue(all(p == -1, filter=not gender))
                - mn: multivariate_normal([0, 0], [[1.5, 1], [1, 1.5]])
                - assertEqual(mn.shape, (count(), 2))

            test_all():
                # scalars
                - assertTrue(all(True))
                - assertFalse(all(False))
                # vectors
                - assertTrue(all(id >= 0))
                - assertFalse(all(id < 0))
                - assertFalse(all(id > 100))
                # with a filter
                - assertTrue(all(id >= 0, filter=MALE))
                - assertFalse(all(id < 0, filter=MALE))
                - assertFalse(all(id > 100, filter=MALE))
                - assertTrue(all(MALE, filter=MALE))
                - assertFalse(all(FEMALE, filter=MALE))

            test_any():
                # scalars
                - assertTrue(any(True))
                - assertFalse(any(False))
                # vectors
                - assertTrue(any(id >= 0))
                - assertFalse(any(id < 0))
                - assertTrue(any(id > 100))
                # with a filter
                - assertTrue(any(id >= 0, filter=MALE))
                - assertFalse(any(id < 0, filter=MALE))
                - assertTrue(any(id > 100, filter=MALE))
                - assertTrue(any(MALE, filter=MALE))
                - assertFalse(any(FEMALE, filter=MALE))

            test_count():
                # no filter and no weights
                - population: count()
                # not very useful but I could not think of something better
                - assertTrue(population >= 0)

                # filter and no weights
                - assertEqual(count(MALE) + count(FEMALE), population)
                - assertEqual(count([True, False, True, True]), 3)

                # no filter and weights
                - assertEqual(count(weights=[1, 2, 3, 4]), 10)

                # filter and weights
                - assertEqual(count([True, False, True, True], weights=[1, 2, 3, 4]), 8)

            test_sum():
                # without weight
                # ==============

                # simple
                - population_age: sum(age)

                # explicit filter
                - males_age: sum(age, filter=MALE)
                - assertEqual(males_age, sum(age * MALE))
                - females_age: sum(age, filter=FEMALE)
                - assertEqual(females_age, sum(age * FEMALE))
                - assertEqual(males_age + females_age, population_age)

                # implicit/contextual filter
                # assign to each man the sum of men ages and to each woman
                # the sum of women ages
                - filtered: if(MALE, sum(age), sum(age))
                - assertEqual(count(filtered == males_age),
                              count(MALE))
                - assertEqual(count(filtered == females_age),
                              count(FEMALE))

                # both implicit and explicit filter
                # assign to each man the sum of men ages and to each woman
                # the sum of women ages
                - age_men_10plus: sum(age, filter=MALE and age >= 10)
                - age_women_20plus: sum(age, filter=FEMALE and age >= 20)
                - test_value: if(MALE, sum(age, filter=age >= 10),
                                       sum(age, filter=age >= 20))
                - assertEqual(count(test_value == age_men_10plus),
                              count(MALE))
                - assertEqual(count(test_value == age_women_20plus),
                              count(FEMALE))

                # nested contextual filter (this is more of a test of nested
                # contextual filters than sum but it makes more sense to
                # have it here anyway)
                - teen: age >= 10 and age < 20
                - test: if(MALE,
                           if(teen, sum(age), sum(age)),
                           sum(age))
                - male_teens_age: sum(age, MALE and teen)
                - male_other_age: sum(age, MALE and not teen)
                - assertEqual(count(test == male_teens_age),
                              count(MALE and teen))
                - assertEqual(count(test == male_other_age),
                              count(MALE and not teen))
                - assertEqual(count(test == females_age),
                              count(FEMALE))

                # with missing
                - ints: array([1, -1, 2])
                - floats: array([1.0, nan, 2.0])
                - assertEqual(sum(ints), 3)
                - assertEqual(sum(floats), 3.0)

                # with missing but skip_na=False
                - assertEqual(sum(ints, skip_na=False), 2)
                - res: sum(floats, skip_na=False)
                # fails with numba
                - assertTrue(res != res)
#                - assertTrue(not (res == res))

                # with missing and filter
                - assertEqual(sum(if(age > 10, -1, age), filter=gender),
                              sum(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(sum(if(age > 10, nan, f_age), filter=gender),
                              sum(f_age, filter=age <= 10 and gender))

                # bool expr
                - b: [False, True, True]
                - sum_bool: sum(b)
                - assertEqual(sum_bool, 2)

                # scalar
                # currently fails
#                - assertEqual(sum(2), 2 * count())
                - assertEqual(sum(2, filter=MALE), 2 * count(MALE))

                # with weight
                # ===========

                # ints
                - weights: array([3, 2, 1])
                - filter: array([False, True, True])
                - ints: array([1, -1, 2])

                - assertEqual(sum(ints, weights=weights), 5)
                - assertEqual(sum(ints, filter=filter, weights=weights), 2)
                - assertEqual(sum(ints, weights=weights, skip_na=False), 3)
                - assertEqual(sum(ints, filter=filter, weights=weights, skip_na=False), 0)

                # floats
                - weights: array([3, 2, 1])
                - filter: array([False, True, True])
                - floats: array([1.0, nan, 2.0])
                - assertEqual(sum(floats, weights=weights), 5.0)
                - assertEqual(sum(floats, weights=weights, filter=filter), 2.0)
                - res: sum(floats, weights=weights, skip_na=False)
                - assertTrue(res != res)
                - res: sum(floats, weights=weights, filter=filter, skip_na=False)
                - assertTrue(res != res)

            test_avg():
                # simple
                - assertEqual(avg(age), sum(age) / count())

                # explicit filter
                - assertEqual(avg(age, filter=MALE),
                              sum(age, filter=MALE) / count(MALE))
                - assertEqual(avg(age, filter=FEMALE),
                              sum(age, filter=FEMALE) / count(FEMALE))

                # with missing
                - assertEqual(avg([1.0, nan, 3.0]), 2.0)
                - assertEqual(avg([1, -1, 3]), 2.0)

                # with missing but skip_na=False
                - assertEqual(avg([1, -1, 3], skip_na=False), 1.0)
                - withnan: avg([1.0, nan, 3.0], skip_na=False)
                - assertTrue(withnan != withnan)

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(avg(if(age > 10, -1, age), filter=gender),
                              avg(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(avg(if(age > 10, nan, f_age), filter=gender),
                              avg(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

                # bool expr
                - assertEqual(avg([False, True, True, False]), 0.5)

                # bool expr with filter
                - assertEqual(avg([False, True, True, False], [True, False, False, True]), 0.0)
                - assertEqual(avg([False, True, True, False], [True, True, False, False]), 0.5)
                - assertEqual(avg([False, True, True, False], [False, True, True, False]), 1.0)

                # with weight
                # -----------

                # simple
                - ones: (age + 1) / (age + 1)
                - assertEqual(avg(age, weights=ones), sum(age) / count())

                - weight: randint(1, 11)
                - assertEqual(avg(age, weights=weight), sum(age, weights=weight) / sum(weight))

                # with missing
                - assertEqual(avg([1.0, nan, 3.0], weights=[3, 2, 1]), 1.5)
                - assertEqual(avg([1, -1, 3], weights=[3, 2, 1]), 1.5)

                # with missing but skip_na=False
                - assertEqual(avg([4, -1, 2], weights=[3, 2, 1], skip_na=False), 2.0)
                - withnan: avg([4.0, nan, 2.0], weights=[3, 2, 1], skip_na=False)
                - assertTrue(withnan != withnan)

                # with missing but skip_na=False
                - assertEqual(avg([4, -1, 2], weights=[3, 2, 1], skip_na=False), 2.0)
                - withnan: avg([4.0, nan, 2.0], weights=[3, 2, 1], skip_na=False)
                - assertTrue(withnan != withnan)

                # with a scalar
                - assertEqual(avg(1.0), 1.0)

            test_std():
                # bool expr
                - assertEqual(std([False, True, True, False]), 0.5)

                # int without filter
                - assertEqual(std([1, 3]), 1.0)
                - assertEqual(std([3, 6]), 1.5)
                - assertEqual(std([2, 6, 6, 2]), 2.0)
                - assertEqual(round(std([1, 2, 3]), 3), 0.816)
                - assertEqual(round(std([3, 6, 6, 1]), 3), 2.121)

                # with a filter
                - assertEqual(std([1, 2, 3], [True, False, True]), 1.0)
                - assertEqual(std([2, 6, 6, 2], [True, True, False, False]), 2.0)
                - assertEqual(std([2, 6, 6, 2], [True, False, False, True]), 0.0)

                # with weights
                - assertEqual(round(std([3, 6, 1], weights=[1, 2, 1]), 3), 2.121)
                # with filter and weights
                - res: std([2, 6, 99, 2], filter=[True, True, False, True], weights=[1, 2, 9, 1])
                - assertEqual(round(res, 3), 2.0)

            test_min():
                # simple scalars
                - assertEqual(min([2, 1, 3]), 1)
                - assertEqual(min([2.0, 1.0, 3.0]), 1.0)

                # simple column
                - assertEqual(min(age), 0)

                # explicit filter
                - assertEqual(min(age, filter=age >= 10), 10)

                # with na
                - assertEqual(min([3, -1, 2]), 2)
                - assertEqual(min([3.0, nan, 2.0]), 2.0)

                # with na not skipping
                - assertEqual(min([3, -1, 2], skip_na=False), -1)
                - whnan: min([3.0, nan, 2.0], skip_na=False)
                - assertTrue(whnan != whnan)

                # with na and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(min(if(age > 10, -1, age), filter=gender),
                              min(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(min(if(age > 10, nan, f_age), filter=gender),
                              min(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_max():
                # simple scalars
                - assertEqual(max([2, 1, 3]), 3)
                - assertEqual(max([2.0, 1.0, 3.0]), 3.0)

                # simple column
                - assertTrue(all(age <= max(age)))

                # explicit filter
                - assertEqual(max(age, filter=age <= 20), 20)

                # with na
                - assertEqual(max([3, -1, 2]), 3)
                - assertEqual(max([-3, -1, -2]), -2)
                - assertEqual(max([3.0, nan, 2.0]), 3.0)

                # with na not skipping
                - assertEqual(max([3, -1, 2], skip_na=False), 3)
                - assertEqual(max([-3, -1, -2], skip_na=False), -1)
                - whnan: max([3.0, nan, 2.0], skip_na=False)
                - assertTrue(whnan != whnan)

                # with na and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(max(if(age < 10, -1, age), filter=gender),
                              max(age, filter=age >= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(max(if(age < 10, nan, f_age), filter=gender),
                              max(f_age, filter=age >= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_median():
                # simple without filter
                - median_age: median(age)
                - num_young: count(age < median_age)
                - num_median: count(age == median_age)
                - num_old: count(age > median_age)
                - num_total: count()

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

                # scalar (there is not much point but it should not crash)
                - median_age2: median(median_age)
                - assertEqual(median_age, median_age2)

                # with an explicit filter
                - median_age: median(age, filter=gender)
                - num_young: count(gender and (age < median_age))
                - num_median: count(gender and (age == median_age))
                - num_old: count(gender and (age > median_age))
                - num_total: count(gender)

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

                - x: [1, 2, 3]
                - assertEqual(median(x), 2.0)
                - assertEqual(median(x, weights=[0.1, 0.1, 0.1]), 2.0)

                - assertEqual(median([1, 1, 2, 3]), 1.5)
                - assertEqual(median(x, weights=[2, 1, 1], weights_type='freq'), 1.5)
                - assertEqual(median(x, weights=[2, 1, 1]), 2.0)

                - x: [1, 2, 3, 4]
                - assertEqual(median(x), 2.5)
                - assertEqual(median(x, weights=[0.1, 0.1, 0.1, 0.1]), 2.5)
                - assertEqual(median(x, weights=[0.2, 0.9, 0.3, 0.1]), 2.5)
                - assertEqual(median(x, weights=[0.9, 0.2, 0.3, 0.1]), 2.0)

                # Check using duplicated values
                - assertEqual(median([1, 2, 2, 3], weights=[0.2, 0.1, 0.4, 0.1]), 2.0)

            test_percentile():
                # without filter
                - age_10p: percentile(age, 10)
                - num_young: count(age < age_10p)
                - num_10p: count(age == age_10p)
                - num_old: count(age > age_10p)
                - num_total: count()

                # the + 1 are necessary in case the Nth value is between two
                # different values because in that case, the percentile is a
                # linear approximation of both values, and thus the number of
                # values smaller can be 1 more. Note that if we are between
                # two indices but the values at those two indices is the same
                # we do not have a problem, that is why this problem only
                # triggers rarely in our test because many individuals have
                # the same age.
                # >>> a = [0, 1, 2, 3, 4]
                # >>> np.percentile(a, 25)
                # 1.0
                # >>> np.sum(a < 1.0)
                # 1
                # >>> np.percentile(a, 26)
                # 1.04
                # >>> np.sum(a < 1.04)
                # 2
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

                # with a filter
                - age_10p: percentile(age, 10, filter=gender)
                - num_young: count(gender and (age < age_10p))
                - num_10p: count(gender and (age == age_10p))
                - num_old: count(gender and (age > age_10p))
                - num_total: count(gender)
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

                - q: array([0, 25, 50, 100])
                - res: percentile([1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3], q=q)
                - assertEqual(res, [1.0, 1.75, 2.0, 3.0])
                - res: percentile([1, 2, 3], weights=[3, 5, 4], q=q, weights_type='freq')
                - assertEqual(res, [1.0, 1.75, 2.0, 3.0])

                - q: array([0, 10, 40, 50, 60, 90, 100])
                - res: percentile([1, 2, 3], q=q)
                - assertEqual(round(res, 10), [1.0, 1.2, 1.8, 2.0, 2.2, 2.8, 3.0])
                - res: percentile([1, 2, 3], weights=[0.1, 0.1, 0.1], q=q, weights_type='other')
                - assertEqual(res, [1.0, 1.2, 1.8, 2.0, 2.2, 2.8, 3.0])

                - res: percentile([1, 2, 3, 4], weights=[0.1, 0.1, 0.1, 0.1], q=q, weights_type='other')
                - assertEqual(res, [1.0, 1.3, 2.2, 2.5, 2.8, 3.7, 4.0])
                - res: percentile([1, 2, 3, 4], q=q, weights_type='other')
                - assertEqual(res, [1.0, 1.3, 2.2, 2.5, 2.8, 3.7, 4.0])

                - res: percentile([1, 2, 3, 4], weights=[0.2, 0.9, 0.3, 0.1], q=q, weights_type='other')
                - assertEqual(round(res, 10), [2.0, 2.0, 2.2, 2.5, 2.8, 3.7, 4.0])
                - res: percentile([1, 2, 3, 4], weights=[0.9, 0.2, 0.3, 0.1], q=q, weights_type='other')
                - assertEqual(round(res, 10), [1.0, 1.0, 1.4, 2.0, 2.6, 3.7, 4.0])

                # Check using duplicated values
                - res: percentile([1, 2, 2, 3], weights=[0.2, 0.1, 0.4, 0.1], q=q, weights_type='other')
                - assertEqual(res, [1.0, 1.3, 2.0, 2.0, 2.0, 2.7, 3.0])

            test_gini():
                # simple expr
                - assertEqual(gini([1, 1, 1]), 0)
                - assertEqual(gini([0, 0, 0, 1]), 0.75)
                - assertEqual(gini([1.0, 0.0, 1.0, 1.0]), 0.25)

                # examples from wikipedia (https://en.wikipedia.org/wiki/Gini_coefficient)
                # I used the values divided by 1000 for short
                - assertEqual(gini([20, 30, 40, 50, 60]), 0.2)
                - assertEqual(gini([9, 40, 48, 48, 55]), 0.2)
                - assertIsClose(round(gini([50, 90, 130, 170, 270]), 3), 0.293)

                # with missing values
                - assertEqual(gini([0, -1, 1, 0, 0, -1]), 0.75)
                - assertEqual(gini([0.0, nan, 1.0, 0.0, 0.0, nan]), 0.75)

                # with missing values without skipping
                - assertEqual(gini([0, -1, 1, 1, 0], skip_na=False), 2.0)
                - wh_nan: gini([0.0, nan, 1.0, 0.0, nan], skip_na=False)
                - assertTrue(wh_nan != wh_nan)

                # boolean expr
                - assertEqual(gini([False, False, False, True]), 0.75)

                # with an explicit filter
                - show('gini(age)', gini(age))
                - show('gini(age) by sex:',
                       gini(age, filter=MALE),
                       '/',
                       gini(age, filter=FEMALE))

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(gini(if(age > 10, -1, age), filter=gender),
                              gini(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(gini(if(age > 10, nan, f_age), filter=gender),
                              gini(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

                # check with weights
                - x: [3, 1, 7, 2, 5]
                - w: [1, 2, 3, 4, 5]

                - assertEqual(round(gini(x, weights=w), 10), 0.2983050847)
                - assertEqual(gini([0.25, 0.75], weights=[1, 1]), 0.25)

            test_choice():
                - intchoice: choice([0, 5, 10], [0.1, 0.2, 0.7])
                - num0: count(intchoice == 0)
                - num5: count(intchoice == 5)
                - num10: count(intchoice == 10)
                - num_total: count()
                - assertEqual(num0 + num5 + num10, num_total)

                # test choices and probabilities being expressions
                - zero: avg(age) - avg(age)

                - p0: zero + 0.1
                - p1: zero + 0.3

                - fchoice: choice([zero, zero + 1.0, zero + 2.0],
                                  [p0, p1, 1.0 - p0 - p1])

                - num0: count(fchoice == 0.0)
                - num1: count(fchoice == 1.0)
                - num2: count(fchoice == 2.0)
                - assertEqual(num0 + num1 + num2, num_total)
                # this assertion can fail but it should occur pretty rarely
                - assertTrue((num0 < num1) and (num1 < num2))

                - show(groupby(choice([zero, zero + 1.0], [p0, 1.0 - p0]),
                               choice([0, 1], [0.3, 0.7]),
                               choice([0, 1])))

                # cases where choice should raise an exception
#                - bad1: choice([0, 1, 2], [0.5, 0.2, 0.1]) # sum < 1
#                - bad2: choice([0, 1, 2], [0.5, 0.4, 0.3]) # sum > 1

                # cases where choice used to print a warning but crashes
                # since we updated numpy.
#                - warn1: choice([0, 1], [0.5, 0.499999])  # sum slightly < 1
#                - warn2: choice([0, 1], [0.5, 0.5000009]) # sum slightly > 1

                # test individual probability
                - seed(0)
                - p0: if(gender, 0.1, 0.3)
                - p5: if(gender, 0.2, 0.4)
                - p10: if(gender, 0.7, 0.3)
                - intchoice: choice([0, 5, 10], [p0, p5, p10])
                - num0: count(intchoice == 0)
                - num5: count(intchoice == 5)
                - num10: count(intchoice == 10)
                - assertTrue(num0 > 0)
                - assertTrue(num5 > 0)
                - assertTrue(num10 > 0)
                - assertEqual(num0 + num5 + num10, num_total)

                # test probabilities from external file
                - seed(0)
                - intchoice2: choice('ext_choice.csv')
                - assertEqual(intchoice, intchoice2)

                # test probabilities from expr/global
                - seed(0)
                - intchoice3: choice(EXT_CHOICE.mean('gender'))
                - num0: count(intchoice3 == 0)
                - num5: count(intchoice3 == 5)
                - num10: count(intchoice3 == 10)
                - assertTrue(num0 > 0)
                - assertTrue(num5 > 0)
                - assertTrue(num10 > 0)
                - assertEqual(num0 + num5 + num10, num_total)


                - global_choice: choice(CHOICE2D.rename('choices', 'outcomes'))
                # TODO: use a single 2D groupby (gender & not gender)
                - w: groupby(global_choice, filter=not gender, percent=True)
                - w1: w[1]
                - w2: w[2]
                - w3: w[3]
                - assertTrue(17 < w1 and w1 < 23) # should be approx 20%
                - assertTrue(27 < w2 and w2 < 33) # should be approx 30%
                - assertTrue(47 < w3 and w3 < 53) # should be approx 50%
                - m: groupby(global_choice, filter=gender, percent=True)
                - m1: m[1]
                - m2: m[2]
                - m3: m[3]
                - assertTrue(27 < m1 and m1 < 33) # should be approx 30%
                - assertTrue(47 < m2 and m2 < 53) # should be approx 50%
                - assertTrue(17 < m3 and m3 < 23) # should be approx 20%

                - global_choice: choice(CHOICE2DT.rename('choices', 'outcomes'))
                - w: groupby(global_choice, filter=not gender, percent=True)
                - w1: w[1]
                - w2: w[2]
                - w3: w[3]
                - assertTrue(17 < w1 and w1 < 23) # should be approx 20%
                - assertTrue(27 < w2 and w2 < 33) # should be approx 30%
                - assertTrue(47 < w3 and w3 < 53) # should be approx 50%
                - m: groupby(global_choice, filter=gender, percent=True)
                - m1: m[1]
                - m2: m[2]
                - m3: m[3]
                - assertTrue(27 < m1 and m1 < 33) # should be approx 30%
                - assertTrue(47 < m2 and m2 < 53) # should be approx 50%
                - assertTrue(17 < m3 and m3 < 23) # should be approx 20%

                # choice with duplicate/ambiguous labels
                #  work gender outcomes
                #                0   5  10  15
                # FALSE  FALSE 0.7 0.1 0.1 0.1
                # FALSE   TRUE 0.1 0.7 0.1 0.1
                #  TRUE  FALSE 0.1 0.1 0.7 0.1
                #  TRUE   TRUE 0.1 0.1 0.1 0.7
                - outcome: choice('ext_choice_ambiguous.csv')
                - actual: groupby(work, gender, outcome) / groupby(work, gender)
                - min_: array([[[60,  5,  5,  5],
                               [ 5, 60,  5,  5]],
                              [[ 5,  5, 60,  5],
                               [ 5,  5,  5, 60]]]) / 100
                - max_: array([[[80, 15, 15, 15],
                               [15, 80, 15, 15]],
                              [[15, 15, 80, 15],
                               [15, 15, 15, 80]]]) / 100
                - check: min_ < actual and actual < max_
                - assertTrue(check.all())

            test_groupby():
                # scalar dim
                - num_males: count(gender)
                - by_constant: groupby(num_males)
                - assertEqual(by_constant, [count()])

                # scalar (global) dim
                - by_constant: groupby(MINR)
                - assertEqual(by_constant, [count()])

                # 1 normal dim, 1 scalar dim
                - by_constant_gender: groupby(gender, MINR)
                - assertEqual(by_constant_gender,
                              [[count(not gender)], [count(gender)]])

                # 1 normal dim
                - by_gender: groupby(gender)
                - assertEqual(by_gender, [count(not gender), count(gender)])

                # 2 dim
                - by_agegroup_gender: groupby(agegroup, gender)
                - assertEqual(by_agegroup_gender.ndim, 2)
                - assertEqual(by_agegroup_gender.axes.names,
                              ['agegroup', 'gender'])
                # FIXME
#                - assertTrue(by_agegroup_gender.row_totals.__len__() > 0)
#                - assertEqual(by_agegroup_gender.col_totals,
#                              [count(not gender),
#                               count(gender),
#                               count()])
                - assertEqual(by_agegroup_gender.i[0],
                              [count(agegroup == -1 and not gender),
                               count(agegroup == -1 and gender)])
                - assertEqual(by_agegroup_gender[0],
                              [count(agegroup == 0 and not gender),
                               count(agegroup == 0 and gender)])

                # fails as expected, but if we can fix this, it would be nice
#                - show('groupby scalar', groupby(True, gender))
                # this is currently broken
#                - show('groupby scalar', groupby(avg(age), gender))

                # grouping by expressions (not only simple columns)
                - show(groupby(round(logit_score(0.0), 1)))
                - show('groupby global', groupby(if(gender, 65, WEMRA), gender))

                # with expr=
                - explicit_count: groupby(gender, expr=count())
                - assertEqual(explicit_count,
                              [count(not gender), count(gender)])

                - avg_age: groupby(gender, expr=avg(age))
                - assertEqual(avg_age, [avg(age, filter=not gender),
                                        avg(age, filter=gender)])

                - show('min', groupby(agegroup, expr=min(age)))
                - temp_scalar: avg(age)
                - show('wh scalar variable', groupby(agegroup, expr=temp_scalar * min(age)))

                # with expr= and filter
                - avg_age_work: groupby(gender, expr=avg(age), filter=work)
                - assertEqual(avg_age_work,
                              [avg(age, filter=work and not gender),
                               avg(age, filter=work and gender)])
# FIXME
#                - assertEqual(avg_age_work.row_totals,
#                              [avg(age, filter=work)])
                # expr=id
                - ids_by_gender: groupby(gender, expr=id, filter=id < 20)
                - assertEqual(ids_by_gender[False], id[id < 20 and not gender])
                - assertEqual(ids_by_gender[True], id[id < 20 and gender])

                # expr=id with the same number in each category (because in
                # that case dtype is int, instead of object)
                - ids_by_id: groupby(id >= 10, expr=id, filter=id < 20)
                #- assertEqual(ids_by_id[0], id[id < 10])
                - assertEqual(ids_by_id[False], id[id < 10])
                - assertEqual(ids_by_id[True], id[id >= 10 and id < 20])

                # expr=scalar
                - ten_by_gender: groupby(gender, expr=10)
                - assertEqual(ten_by_gender, [10, 10])

                # empty result
                - empty: groupby(gender, filter=age > 200)
                - show(empty)
                - assertEqual(empty, [])
                - empty_percent: groupby(gender, filter=age > 200,
                                         percent=True)
                - assertEqual(empty_percent, [])
                - show(empty_percent)

                # ...
                - num_persons2_percent: show(groupby(agegroup, gender, percent=True))

                - num_persons_weight_percent: show(groupby(agegroup, gender, expr=sum(weight), percent=True))
                - num_persons_csv: csv(groupby(agegroup, gender), suffix='groupby')
                - num_persons3: show(groupby(agegroup, work, gender))

                - ismarried: partner_id != -1
                - num_persons3t: show(groupby(agegroup, gender, ismarried))
                - num_workless: show(groupby(agegroup, gender,
                                          expr=count(not work)))
                - num_married: show(groupby(agegroup, gender,
                                            expr=count(ismarried)))
                - num_partner_work: show(groupby(agegroup, gender,
                                                 expr=count(partner.work)))
                - num_bad_partner: show(groupby(agegroup, gender,
                                                expr=count((partner_id != -1) and (partner.partner.id != id))))
                - agediff: show(groupby(agegroup, gender,
                                        expr=avg(age - if(partner.age == -1, nan, partner.age))))
#                                        expr=avg(abs(age - if(partner.age == -1, nan, partner.age)))))
#                - minmax_age: show(groupby(id / 100, gender, expr=max(age) - min(age)))

                # groupby in expressions
                # ----------------------
                - simple_expr: by_agegroup_gender * 2
                - assertEqual(simple_expr.ndim, 2)
                - assertEqual(simple_expr.axes.names, ['agegroup', 'gender'])
#                - assertEqual(simple_expr.row_totals, None)
#                - assertEqual(simple_expr.col_totals, None)

                # We cannot use groupby(age, filter=gender) because in that
                # case we might have missing age categories whereas we want
                # them to be empty instead.
                - men_by_age: groupby(age, expr=count(gender))
                - assertEqual(men_by_age.axes.names, ['age'])
                - by_age: groupby(age)
                - assertEqual(by_age.axes.names, ['age'])
                - men_prop_by_age: men_by_age / by_age
                - assertEqual(men_prop_by_age.axes.names, ['age'])

                # this does not trigger the same path than men_prop_by_age
                # (even though both go through ne), but this one creates hidden
                # temporary variables in EvaluableExpression.as_simple_expr
                # while the other does not
                - men_prop2: groupby(age, expr=count(gender)) / groupby(age)
                - assertEqual(men_prop2.axes.names, ['age'])

                # Yet another way to compute it. The division in:
                # count(gender) / count() is done by numexpr and since those are
                # scalars, it returns 0d arrays, so the result used to be
                # (before we special-cased this) an array of 0d arrays, which
                # caused problems when reused in an expression evaluated by
                # numexpr
                - men_prop3: groupby(age, expr=count(gender) / count())

                - assertEqual(men_prop_by_age, men_prop2)
                - assertEqual(men_prop_by_age, men_prop3)
                - men_prop_in_expr: men_prop2 + men_prop3
                - assertEqual(men_prop_in_expr, men_prop2 * 2)

                # does not work for some reason
                #- min_count_by_gender: min(by_agegroup_gender, axis=0)
                - min_count_by_gender: by_agegroup_gender.min('agegroup')
                - qshow(min_count_by_gender)
                - assertEqual(min_count_by_gender.shape, (2,))
                - assertEqual(min_count_by_gender.axes.names, ['gender'])
#                - assertEqual(min_count_by_gender.row_totals, None)
#                - assertEqual(min_count_by_gender.col_totals, None)

                #- min_count_by_agegroup: min(by_agegroup_gender, axis=1)
                - min_count_by_agegroup: by_agegroup_gender.min('gender')
                - assertEqual(min_count_by_agegroup.shape, (16,))
                - assertEqual(min_count_by_agegroup.axes.names, ['agegroup'])
#                - assertEqual(min_count_by_gender.row_totals, None)
#                - assertEqual(min_count_by_gender.col_totals, None)

            show_weight():
                - show("avg weight", avg(weight),
                       "total population", sum(weight))

            test_imported_process():
                - qshow(imported_field1)
                - assertEquiv(imported_field1, -1)
                - assertEqual(imported_field2, age + 2)

            test_array():
                # - remove(id % 1000 < 999)
                - v0: age
                - v1: age + 1
                - v2: age + 2
                - v3: age + 3
                - v4: age + 4
                - v5: age + 5
                - arr: array([v3, v1, v2, v5, v0, v4])
                - sorted_arr: sort(arr, axis=0)
                - highest1: sorted_arr[-1]
                - highest2: sorted_arr[-2]
                - highest3: sorted_arr[-3]
                - assertEqual(highest1, v5)
                - assertEqual(highest2, v4)
                - assertEqual(highest3, v3)
                # sum of 3 highest
                - sum_highest: sorted_arr[-3:].sum(axis=0)
                - assertEqual(sum_highest, highest1 + highest2 + highest3)

            generate():
                - new('person', number=100000,
                      age=randint(0, 98),
                      dead=False,
                      gender=choice([False, True]),
                      work=choice([False, True]),
                      partner_id=-1,
                      f_id=-1,
                      m_id=-1,
                      hh_id=-1)

            test_default_value():
                - assertEquiv(undefaulted_bool_variable, False)
                - assertEquiv(undefaulted_integer_variable, -1)
                - assertTrue(all(undefaulted_float_variable !=
                                 undefaulted_float_variable))
                - assertEquiv(defaulted_integer_variable, 99)
                - assertEquiv(defaulted_float_variable, 99.99)
                - assertTrue(all(defaulted_bool_variable))

            test_multi_align():
                # it also works for hard-coded values, e.g.
                #- target_values: ([5, 10, 15])
                #- target_props: ([0.2, 0.5, 0.3])
                - target_values: MULTIALIGN.axes.values
                - target_props: MULTIALIGN
                # this is a strange way to set everybody to -1 (to workaround a small bug)
                - new_value: if(gender, -1, -1)
                - target_idx: 0
                # TODO: implementing for ... in ... would make this so much cleaner
                - while target_idx < target_values.__len__():
                    - target_value: target_values.i[target_idx]
                    - target_prop: target_props[target_value]
                    # this could be made different depending on target_value but needs some randomness (otherwise we
                    # get successive ids for each values, which is bad
                    - target_score: uniform()
                    - to_target: align(target_score, target_prop, leave=new_value != -1)
                    - new_value: if(to_target, target_value, new_value)
                    - target_idx: target_idx + 1
                # make sure everybody got a new value, by assigning any remaining individuals to the last bin.
                # Ideally we should add them to the group which is farthest from its target
                - new_value: if(new_value == -1, target_values.labels[-1], new_value)
                - result: groupby(new_value, percent=True)
                - show(result)
                - result5: result[5]
                - result10: result[10]
                - result15: result[15]
                - assertTrue(19.9 < result5 and result5 < 20.1)   # should be very close to 20%
                - assertTrue(49.9 < result10 and result10 < 50.1) # should be very close to 50%
                - assertTrue(29.9 < result15 and result15 < 30.1) # should be very close to 30%

#            test_merge:
#                # no fields argument => use all fields in file
#                # XXX: do we accept merging "into" past data or only in the current period?
#                - merge(load('param/person.csv'))
#                # fields argument present, only load those.
#                # XXX: the big question is do we want period & id to be implicit
#                # * implicit is annoying if you have data without period that you want to load in the current period
#                # * implicit breaks if I use the same function to load global tables
#                #   (and without a special argument)
#                # vs
#                # * explicit would be error-prone because people would think
#                #   it is implicit like in entity fields. The worst case, is
#                #   that they declare only id and not period and the wrong
#                #   period gets loaded.
#                - table: load('param/person.csv',
#                              fields=[('period', int), ('id', int), ('age', int)])
#                - merge(table)
#                # we need to be able to select what to load and what to merge (or is selecting what to load is enough?)
#                - merge(table[2011]))
#                # vs
#                - merge(load('param/person.csv',
#                             fields=[('period', int), ('id', int), ('age', int)], filter=period == 2011)

            test_show():
                - show("yada yada")

            test_load():
                - arr: load('param/mig.csv', type=float)
                - assertEqual(arr.shape, (2, 121, 61))
                - assertEqual(arr.axes.names, ['gender', 'age', 'period'])
                - table: load('param/othertable.csv',
                              fields=[('PERIOD', int), ('INTFIELD', int), ('FLOATFIELD', float)])
                - assertEqual(table.shape, (31,))

            test_global_constants():
                - assertEqual(BOOL_CONSTANT1, False)
                - assertEqual(BOOL_CONSTANT2, True)
                - assertEqual(INT_CONSTANT1, -1)
                - assertEqual(INT_CONSTANT2, 42)
                - assertEqual(FLOAT_CONSTANT1, -1.)
                - assertEqual(FLOAT_CONSTANT2, 3.1415)
                - assertEqual(STR_CONSTANT1, "abc")
                - assertEqual(STR_CONSTANT2, "a\"b\"c")
                - assertEqual(STR_CONSTANT3, "a/b/c")
                - assertEqual(STR_CONSTANT4, "a\\b\\c")

simulation:
    init:
        - household: [init_region]
        - person: [
#            generate,
            test_init,
            test_dump_init,
            test_remove_init
        ]
#        - household: [setweight, check]
#        # pass 1: weight up to 2
#        - household: [expand]
#        - person: [expand]
#        # pass 2: weights up to 4
#        - household: [expand]
#        - person: [expand]
#        # pass 3: weights up to 8
#        - household: [expand]
#        - person: [expand]
#        # pass 4: weights up to 16
#        - household: [expand]
#        - person: [expand]
#        # pass 5: weights up to 32
#        - household: [expand]
#        - person: [expand]
#
#        - household: [check]

    processes:
        - person: [
#                   bp,
                   test_assert,
                   test_literals,
                   compute_agegroup,
                   test_remove,

                   # basic
                   hybrid_temp_global,
                   set_hybrid_temp_global,
                   check_hybrid_temp_global,

                   set_temp_global,
                   check_temp_global,

#                   test_issue120,

                   test_expr,
                   test_trunc,

                   # random
                   test_uniform,
                   test_otherrandom,

                   test_seed,

                   # test the charts before test_new messes the demography
#                   test_charts,

                   # ...
                   test_logit,
                   test_logistic,

                   test_attr,
                   test_subscript,
                   test_call,
#                   test_issue119,
#                   test_issue126,
                   hybrid_test,
                   test_hybrids,

                   test_periodic_globals,
                   test_other_globals,
                   test_globals_nd,
                   test_autoindex,

                   test_macro,
                   test_compound,

                   test_while,
                   test_pi_nilakantha,

#                   test_extra_comma,
#                   test_uninitialized_var,

                   # lifecycle
                   test_new,
                   test_clone,

                   # aggregates
                   test_all,
                   test_any,
                   test_count,
                   test_sum,
                   test_avg,
                   test_std,
                   test_min,
                   test_max,
                   test_median,
                   test_percentile,
                   test_gini,

                   # regressions
                   test_extexpr,
                   test_logit_score,
                   test_logit_regr,
                   test_cont_regr,
                   test_log_regr,

                   # temporal
                   test_lag,
                   test_value_for_period,
                   test_duration,

                   # links
                   test_o2m,
                   test_lag_o2m,
                   test_mixed_links,

                   # output
                   test_groupby,
                   test_dump,
                   test_csv,

                   imported_process,
                   test_imported_process,

                   # alignment
                   test_align,
                   test_align_abs,
                   test_align_abs_sidewalk,

                   # misc
                   test_choice,
                   show_weight,
                   test_array,
                   test_default_value,
                   test_show,
                   test_load,
                   test_multi_align,
                   test_global_constants,
        ]
        - household: [
            composition,
            test_align_abs_link,
            test_align_link,
#            dump_csv_h,
        ]

#    input:
#        method: void
#        file: none

    output:
        path: output
        file: simulation.h5

    # does not play nicely with recursive functions (because dump wants to
    # access a local variable between the time it is purged from the local scope
    # and the time it is restored from the backup) nor with functions with
    # multiple while loops (because those currently have the same "name".
#    autodump: True
#    autodiff: True

    random_seed: 0
    periods: 2
    logging:
        level: processes
#        timings: False
#    skip_shows: True
#    assertions: skip
